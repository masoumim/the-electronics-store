
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model app_user
 * 
 */
export type app_user = $Result.DefaultSelection<Prisma.$app_userPayload>
/**
 * Model cart
 * 
 */
export type cart = $Result.DefaultSelection<Prisma.$cartPayload>
/**
 * Model cart_product
 * 
 */
export type cart_product = $Result.DefaultSelection<Prisma.$cart_productPayload>
/**
 * Model order
 * 
 */
export type order = $Result.DefaultSelection<Prisma.$orderPayload>
/**
 * Model order_product
 * 
 */
export type order_product = $Result.DefaultSelection<Prisma.$order_productPayload>
/**
 * Model product
 * 
 */
export type product = $Result.DefaultSelection<Prisma.$productPayload>
/**
 * Model session
 * 
 */
export type session = $Result.DefaultSelection<Prisma.$sessionPayload>
/**
 * Model address
 * 
 */
export type address = $Result.DefaultSelection<Prisma.$addressPayload>
/**
 * Model checkout_session
 * 
 */
export type checkout_session = $Result.DefaultSelection<Prisma.$checkout_sessionPayload>
/**
 * Model payment_card
 * 
 */
export type payment_card = $Result.DefaultSelection<Prisma.$payment_cardPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more App_users
 * const app_users = await prisma.app_user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more App_users
   * const app_users = await prisma.app_user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.app_user`: Exposes CRUD operations for the **app_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_users
    * const app_users = await prisma.app_user.findMany()
    * ```
    */
  get app_user(): Prisma.app_userDelegate<ExtArgs>;

  /**
   * `prisma.cart`: Exposes CRUD operations for the **cart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carts
    * const carts = await prisma.cart.findMany()
    * ```
    */
  get cart(): Prisma.cartDelegate<ExtArgs>;

  /**
   * `prisma.cart_product`: Exposes CRUD operations for the **cart_product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cart_products
    * const cart_products = await prisma.cart_product.findMany()
    * ```
    */
  get cart_product(): Prisma.cart_productDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.orderDelegate<ExtArgs>;

  /**
   * `prisma.order_product`: Exposes CRUD operations for the **order_product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Order_products
    * const order_products = await prisma.order_product.findMany()
    * ```
    */
  get order_product(): Prisma.order_productDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.productDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.sessionDelegate<ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.addressDelegate<ExtArgs>;

  /**
   * `prisma.checkout_session`: Exposes CRUD operations for the **checkout_session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checkout_sessions
    * const checkout_sessions = await prisma.checkout_session.findMany()
    * ```
    */
  get checkout_session(): Prisma.checkout_sessionDelegate<ExtArgs>;

  /**
   * `prisma.payment_card`: Exposes CRUD operations for the **payment_card** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payment_cards
    * const payment_cards = await prisma.payment_card.findMany()
    * ```
    */
  get payment_card(): Prisma.payment_cardDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.6.0
   * Query Engine version: e95e739751f42d8ca026f6b910f5a2dc5adeaeee
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    app_user: 'app_user',
    cart: 'cart',
    cart_product: 'cart_product',
    order: 'order',
    order_product: 'order_product',
    product: 'product',
    session: 'session',
    address: 'address',
    checkout_session: 'checkout_session',
    payment_card: 'payment_card'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'app_user' | 'cart' | 'cart_product' | 'order' | 'order_product' | 'product' | 'session' | 'address' | 'checkout_session' | 'payment_card'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      app_user: {
        payload: Prisma.$app_userPayload<ExtArgs>
        fields: Prisma.app_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_userFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_userFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_userPayload>
          }
          findFirst: {
            args: Prisma.app_userFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_userFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_userPayload>
          }
          findMany: {
            args: Prisma.app_userFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_userPayload>[]
          }
          create: {
            args: Prisma.app_userCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_userPayload>
          }
          createMany: {
            args: Prisma.app_userCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.app_userDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_userPayload>
          }
          update: {
            args: Prisma.app_userUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_userPayload>
          }
          deleteMany: {
            args: Prisma.app_userDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.app_userUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.app_userUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$app_userPayload>
          }
          aggregate: {
            args: Prisma.App_userAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateApp_user>
          }
          groupBy: {
            args: Prisma.app_userGroupByArgs<ExtArgs>,
            result: $Utils.Optional<App_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_userCountArgs<ExtArgs>,
            result: $Utils.Optional<App_userCountAggregateOutputType> | number
          }
        }
      }
      cart: {
        payload: Prisma.$cartPayload<ExtArgs>
        fields: Prisma.cartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cartFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cartFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          findFirst: {
            args: Prisma.cartFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cartFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          findMany: {
            args: Prisma.cartFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>[]
          }
          create: {
            args: Prisma.cartCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          createMany: {
            args: Prisma.cartCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.cartDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          update: {
            args: Prisma.cartUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          deleteMany: {
            args: Prisma.cartDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.cartUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.cartUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cartPayload>
          }
          aggregate: {
            args: Prisma.CartAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCart>
          }
          groupBy: {
            args: Prisma.cartGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CartGroupByOutputType>[]
          }
          count: {
            args: Prisma.cartCountArgs<ExtArgs>,
            result: $Utils.Optional<CartCountAggregateOutputType> | number
          }
        }
      }
      cart_product: {
        payload: Prisma.$cart_productPayload<ExtArgs>
        fields: Prisma.cart_productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cart_productFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cart_productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cart_productFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cart_productPayload>
          }
          findFirst: {
            args: Prisma.cart_productFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cart_productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cart_productFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cart_productPayload>
          }
          findMany: {
            args: Prisma.cart_productFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cart_productPayload>[]
          }
          create: {
            args: Prisma.cart_productCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cart_productPayload>
          }
          createMany: {
            args: Prisma.cart_productCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.cart_productDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cart_productPayload>
          }
          update: {
            args: Prisma.cart_productUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cart_productPayload>
          }
          deleteMany: {
            args: Prisma.cart_productDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.cart_productUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.cart_productUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$cart_productPayload>
          }
          aggregate: {
            args: Prisma.Cart_productAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCart_product>
          }
          groupBy: {
            args: Prisma.cart_productGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Cart_productGroupByOutputType>[]
          }
          count: {
            args: Prisma.cart_productCountArgs<ExtArgs>,
            result: $Utils.Optional<Cart_productCountAggregateOutputType> | number
          }
        }
      }
      order: {
        payload: Prisma.$orderPayload<ExtArgs>
        fields: Prisma.orderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.orderFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.orderFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          findFirst: {
            args: Prisma.orderFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.orderFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          findMany: {
            args: Prisma.orderFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>[]
          }
          create: {
            args: Prisma.orderCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          createMany: {
            args: Prisma.orderCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.orderDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          update: {
            args: Prisma.orderUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          deleteMany: {
            args: Prisma.orderDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.orderUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.orderUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$orderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.orderGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.orderCountArgs<ExtArgs>,
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      order_product: {
        payload: Prisma.$order_productPayload<ExtArgs>
        fields: Prisma.order_productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.order_productFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.order_productFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          findFirst: {
            args: Prisma.order_productFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.order_productFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          findMany: {
            args: Prisma.order_productFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>[]
          }
          create: {
            args: Prisma.order_productCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          createMany: {
            args: Prisma.order_productCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.order_productDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          update: {
            args: Prisma.order_productUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          deleteMany: {
            args: Prisma.order_productDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.order_productUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.order_productUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$order_productPayload>
          }
          aggregate: {
            args: Prisma.Order_productAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrder_product>
          }
          groupBy: {
            args: Prisma.order_productGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Order_productGroupByOutputType>[]
          }
          count: {
            args: Prisma.order_productCountArgs<ExtArgs>,
            result: $Utils.Optional<Order_productCountAggregateOutputType> | number
          }
        }
      }
      product: {
        payload: Prisma.$productPayload<ExtArgs>
        fields: Prisma.productFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findFirst: {
            args: Prisma.productFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          findMany: {
            args: Prisma.productFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>[]
          }
          create: {
            args: Prisma.productCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          createMany: {
            args: Prisma.productCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.productDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          update: {
            args: Prisma.productUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          deleteMany: {
            args: Prisma.productDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.productUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.productUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$productPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.productGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.productCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      session: {
        payload: Prisma.$sessionPayload<ExtArgs>
        fields: Prisma.sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findFirst: {
            args: Prisma.sessionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          findMany: {
            args: Prisma.sessionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>[]
          }
          create: {
            args: Prisma.sessionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          createMany: {
            args: Prisma.sessionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.sessionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          update: {
            args: Prisma.sessionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          deleteMany: {
            args: Prisma.sessionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.sessionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.sessionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$sessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.sessionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionCountArgs<ExtArgs>,
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      address: {
        payload: Prisma.$addressPayload<ExtArgs>
        fields: Prisma.addressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.addressFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.addressFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          findFirst: {
            args: Prisma.addressFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.addressFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          findMany: {
            args: Prisma.addressFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>[]
          }
          create: {
            args: Prisma.addressCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          createMany: {
            args: Prisma.addressCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.addressDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          update: {
            args: Prisma.addressUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          deleteMany: {
            args: Prisma.addressDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.addressUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.addressUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$addressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.addressGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.addressCountArgs<ExtArgs>,
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      checkout_session: {
        payload: Prisma.$checkout_sessionPayload<ExtArgs>
        fields: Prisma.checkout_sessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.checkout_sessionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$checkout_sessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.checkout_sessionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$checkout_sessionPayload>
          }
          findFirst: {
            args: Prisma.checkout_sessionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$checkout_sessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.checkout_sessionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$checkout_sessionPayload>
          }
          findMany: {
            args: Prisma.checkout_sessionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$checkout_sessionPayload>[]
          }
          create: {
            args: Prisma.checkout_sessionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$checkout_sessionPayload>
          }
          createMany: {
            args: Prisma.checkout_sessionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.checkout_sessionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$checkout_sessionPayload>
          }
          update: {
            args: Prisma.checkout_sessionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$checkout_sessionPayload>
          }
          deleteMany: {
            args: Prisma.checkout_sessionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.checkout_sessionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.checkout_sessionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$checkout_sessionPayload>
          }
          aggregate: {
            args: Prisma.Checkout_sessionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCheckout_session>
          }
          groupBy: {
            args: Prisma.checkout_sessionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Checkout_sessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.checkout_sessionCountArgs<ExtArgs>,
            result: $Utils.Optional<Checkout_sessionCountAggregateOutputType> | number
          }
        }
      }
      payment_card: {
        payload: Prisma.$payment_cardPayload<ExtArgs>
        fields: Prisma.payment_cardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payment_cardFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_cardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payment_cardFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_cardPayload>
          }
          findFirst: {
            args: Prisma.payment_cardFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_cardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payment_cardFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_cardPayload>
          }
          findMany: {
            args: Prisma.payment_cardFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_cardPayload>[]
          }
          create: {
            args: Prisma.payment_cardCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_cardPayload>
          }
          createMany: {
            args: Prisma.payment_cardCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.payment_cardDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_cardPayload>
          }
          update: {
            args: Prisma.payment_cardUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_cardPayload>
          }
          deleteMany: {
            args: Prisma.payment_cardDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.payment_cardUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.payment_cardUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$payment_cardPayload>
          }
          aggregate: {
            args: Prisma.Payment_cardAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePayment_card>
          }
          groupBy: {
            args: Prisma.payment_cardGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Payment_cardGroupByOutputType>[]
          }
          count: {
            args: Prisma.payment_cardCountArgs<ExtArgs>,
            result: $Utils.Optional<Payment_cardCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type App_userCountOutputType
   */

  export type App_userCountOutputType = {
    address: number
    cart: number
    checkout_session: number
    order: number
    payment_card: number
  }

  export type App_userCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | App_userCountOutputTypeCountAddressArgs
    cart?: boolean | App_userCountOutputTypeCountCartArgs
    checkout_session?: boolean | App_userCountOutputTypeCountCheckout_sessionArgs
    order?: boolean | App_userCountOutputTypeCountOrderArgs
    payment_card?: boolean | App_userCountOutputTypeCountPayment_cardArgs
  }

  // Custom InputTypes

  /**
   * App_userCountOutputType without action
   */
  export type App_userCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App_userCountOutputType
     */
    select?: App_userCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * App_userCountOutputType without action
   */
  export type App_userCountOutputTypeCountAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: addressWhereInput
  }


  /**
   * App_userCountOutputType without action
   */
  export type App_userCountOutputTypeCountCartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartWhereInput
  }


  /**
   * App_userCountOutputType without action
   */
  export type App_userCountOutputTypeCountCheckout_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checkout_sessionWhereInput
  }


  /**
   * App_userCountOutputType without action
   */
  export type App_userCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }


  /**
   * App_userCountOutputType without action
   */
  export type App_userCountOutputTypeCountPayment_cardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_cardWhereInput
  }



  /**
   * Count Type CartCountOutputType
   */

  export type CartCountOutputType = {
    cart_product: number
    checkout_session: number
  }

  export type CartCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart_product?: boolean | CartCountOutputTypeCountCart_productArgs
    checkout_session?: boolean | CartCountOutputTypeCountCheckout_sessionArgs
  }

  // Custom InputTypes

  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CartCountOutputType
     */
    select?: CartCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountCart_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cart_productWhereInput
  }


  /**
   * CartCountOutputType without action
   */
  export type CartCountOutputTypeCountCheckout_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checkout_sessionWhereInput
  }



  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    order_product: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_product?: boolean | OrderCountOutputTypeCountOrder_productArgs
  }

  // Custom InputTypes

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrder_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_productWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    cart_product: number
    order_product: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart_product?: boolean | ProductCountOutputTypeCountCart_productArgs
    order_product?: boolean | ProductCountOutputTypeCountOrder_productArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountCart_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cart_productWhereInput
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrder_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_productWhereInput
  }



  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    checkout_session: number
    order_order_billing_address_idToaddress: number
    order_order_shipping_address_idToaddress: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkout_session?: boolean | AddressCountOutputTypeCountCheckout_sessionArgs
    order_order_billing_address_idToaddress?: boolean | AddressCountOutputTypeCountOrder_order_billing_address_idToaddressArgs
    order_order_shipping_address_idToaddress?: boolean | AddressCountOutputTypeCountOrder_order_shipping_address_idToaddressArgs
  }

  // Custom InputTypes

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountCheckout_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checkout_sessionWhereInput
  }


  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountOrder_order_billing_address_idToaddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }


  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountOrder_order_shipping_address_idToaddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }



  /**
   * Count Type Payment_cardCountOutputType
   */

  export type Payment_cardCountOutputType = {
    checkout_session: number
    order: number
  }

  export type Payment_cardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkout_session?: boolean | Payment_cardCountOutputTypeCountCheckout_sessionArgs
    order?: boolean | Payment_cardCountOutputTypeCountOrderArgs
  }

  // Custom InputTypes

  /**
   * Payment_cardCountOutputType without action
   */
  export type Payment_cardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment_cardCountOutputType
     */
    select?: Payment_cardCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Payment_cardCountOutputType without action
   */
  export type Payment_cardCountOutputTypeCountCheckout_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checkout_sessionWhereInput
  }


  /**
   * Payment_cardCountOutputType without action
   */
  export type Payment_cardCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
  }



  /**
   * Models
   */

  /**
   * Model app_user
   */

  export type AggregateApp_user = {
    _count: App_userCountAggregateOutputType | null
    _avg: App_userAvgAggregateOutputType | null
    _sum: App_userSumAggregateOutputType | null
    _min: App_userMinAggregateOutputType | null
    _max: App_userMaxAggregateOutputType | null
  }

  export type App_userAvgAggregateOutputType = {
    id: number | null
  }

  export type App_userSumAggregateOutputType = {
    id: number | null
  }

  export type App_userMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
  }

  export type App_userMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    password: string | null
  }

  export type App_userCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    email: number
    password: number
    _all: number
  }


  export type App_userAvgAggregateInputType = {
    id?: true
  }

  export type App_userSumAggregateInputType = {
    id?: true
  }

  export type App_userMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
  }

  export type App_userMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
  }

  export type App_userCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    email?: true
    password?: true
    _all?: true
  }

  export type App_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_user to aggregate.
     */
    where?: app_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_users to fetch.
     */
    orderBy?: app_userOrderByWithRelationInput | app_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_users
    **/
    _count?: true | App_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: App_userAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: App_userSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_userMaxAggregateInputType
  }

  export type GetApp_userAggregateType<T extends App_userAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_user[P]>
      : GetScalarType<T[P], AggregateApp_user[P]>
  }




  export type app_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_userWhereInput
    orderBy?: app_userOrderByWithAggregationInput | app_userOrderByWithAggregationInput[]
    by: App_userScalarFieldEnum[] | App_userScalarFieldEnum
    having?: app_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_userCountAggregateInputType | true
    _avg?: App_userAvgAggregateInputType
    _sum?: App_userSumAggregateInputType
    _min?: App_userMinAggregateInputType
    _max?: App_userMaxAggregateInputType
  }

  export type App_userGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    email: string
    password: string
    _count: App_userCountAggregateOutputType | null
    _avg: App_userAvgAggregateOutputType | null
    _sum: App_userSumAggregateOutputType | null
    _min: App_userMinAggregateOutputType | null
    _max: App_userMaxAggregateOutputType | null
  }

  type GetApp_userGroupByPayload<T extends app_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_userGroupByOutputType[P]>
            : GetScalarType<T[P], App_userGroupByOutputType[P]>
        }
      >
    >


  export type app_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
    address?: boolean | app_user$addressArgs<ExtArgs>
    cart?: boolean | app_user$cartArgs<ExtArgs>
    checkout_session?: boolean | app_user$checkout_sessionArgs<ExtArgs>
    order?: boolean | app_user$orderArgs<ExtArgs>
    payment_card?: boolean | app_user$payment_cardArgs<ExtArgs>
    _count?: boolean | App_userCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app_user"]>

  export type app_userSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    password?: boolean
  }

  export type app_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address?: boolean | app_user$addressArgs<ExtArgs>
    cart?: boolean | app_user$cartArgs<ExtArgs>
    checkout_session?: boolean | app_user$checkout_sessionArgs<ExtArgs>
    order?: boolean | app_user$orderArgs<ExtArgs>
    payment_card?: boolean | app_user$payment_cardArgs<ExtArgs>
    _count?: boolean | App_userCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $app_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_user"
    objects: {
      address: Prisma.$addressPayload<ExtArgs>[]
      cart: Prisma.$cartPayload<ExtArgs>[]
      checkout_session: Prisma.$checkout_sessionPayload<ExtArgs>[]
      order: Prisma.$orderPayload<ExtArgs>[]
      payment_card: Prisma.$payment_cardPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      email: string
      password: string
    }, ExtArgs["result"]["app_user"]>
    composites: {}
  }


  type app_userGetPayload<S extends boolean | null | undefined | app_userDefaultArgs> = $Result.GetResult<Prisma.$app_userPayload, S>

  type app_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<app_userFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: App_userCountAggregateInputType | true
    }

  export interface app_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_user'], meta: { name: 'app_user' } }
    /**
     * Find zero or one App_user that matches the filter.
     * @param {app_userFindUniqueArgs} args - Arguments to find a App_user
     * @example
     * // Get one App_user
     * const app_user = await prisma.app_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends app_userFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, app_userFindUniqueArgs<ExtArgs>>
    ): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one App_user that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {app_userFindUniqueOrThrowArgs} args - Arguments to find a App_user
     * @example
     * // Get one App_user
     * const app_user = await prisma.app_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends app_userFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, app_userFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first App_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_userFindFirstArgs} args - Arguments to find a App_user
     * @example
     * // Get one App_user
     * const app_user = await prisma.app_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends app_userFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, app_userFindFirstArgs<ExtArgs>>
    ): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first App_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_userFindFirstOrThrowArgs} args - Arguments to find a App_user
     * @example
     * // Get one App_user
     * const app_user = await prisma.app_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends app_userFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, app_userFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more App_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_users
     * const app_users = await prisma.app_user.findMany()
     * 
     * // Get first 10 App_users
     * const app_users = await prisma.app_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_userWithIdOnly = await prisma.app_user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends app_userFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, app_userFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a App_user.
     * @param {app_userCreateArgs} args - Arguments to create a App_user.
     * @example
     * // Create one App_user
     * const App_user = await prisma.app_user.create({
     *   data: {
     *     // ... data to create a App_user
     *   }
     * })
     * 
    **/
    create<T extends app_userCreateArgs<ExtArgs>>(
      args: SelectSubset<T, app_userCreateArgs<ExtArgs>>
    ): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many App_users.
     *     @param {app_userCreateManyArgs} args - Arguments to create many App_users.
     *     @example
     *     // Create many App_users
     *     const app_user = await prisma.app_user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends app_userCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, app_userCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a App_user.
     * @param {app_userDeleteArgs} args - Arguments to delete one App_user.
     * @example
     * // Delete one App_user
     * const App_user = await prisma.app_user.delete({
     *   where: {
     *     // ... filter to delete one App_user
     *   }
     * })
     * 
    **/
    delete<T extends app_userDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, app_userDeleteArgs<ExtArgs>>
    ): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one App_user.
     * @param {app_userUpdateArgs} args - Arguments to update one App_user.
     * @example
     * // Update one App_user
     * const app_user = await prisma.app_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends app_userUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, app_userUpdateArgs<ExtArgs>>
    ): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more App_users.
     * @param {app_userDeleteManyArgs} args - Arguments to filter App_users to delete.
     * @example
     * // Delete a few App_users
     * const { count } = await prisma.app_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends app_userDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, app_userDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_users
     * const app_user = await prisma.app_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends app_userUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, app_userUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one App_user.
     * @param {app_userUpsertArgs} args - Arguments to update or create a App_user.
     * @example
     * // Update or create a App_user
     * const app_user = await prisma.app_user.upsert({
     *   create: {
     *     // ... data to create a App_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_user we want to update
     *   }
     * })
    **/
    upsert<T extends app_userUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, app_userUpsertArgs<ExtArgs>>
    ): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of App_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_userCountArgs} args - Arguments to filter App_users to count.
     * @example
     * // Count the number of App_users
     * const count = await prisma.app_user.count({
     *   where: {
     *     // ... the filter for the App_users we want to count
     *   }
     * })
    **/
    count<T extends app_userCountArgs>(
      args?: Subset<T, app_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_userAggregateArgs>(args: Subset<T, App_userAggregateArgs>): Prisma.PrismaPromise<GetApp_userAggregateType<T>>

    /**
     * Group by App_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_userGroupByArgs['orderBy'] }
        : { orderBy?: app_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_user model
   */
  readonly fields: app_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address<T extends app_user$addressArgs<ExtArgs> = {}>(args?: Subset<T, app_user$addressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findMany'> | Null>;

    cart<T extends app_user$cartArgs<ExtArgs> = {}>(args?: Subset<T, app_user$cartArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findMany'> | Null>;

    checkout_session<T extends app_user$checkout_sessionArgs<ExtArgs> = {}>(args?: Subset<T, app_user$checkout_sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'findMany'> | Null>;

    order<T extends app_user$orderArgs<ExtArgs> = {}>(args?: Subset<T, app_user$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'> | Null>;

    payment_card<T extends app_user$payment_cardArgs<ExtArgs> = {}>(args?: Subset<T, app_user$payment_cardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the app_user model
   */ 
  interface app_userFieldRefs {
    readonly id: FieldRef<"app_user", 'Int'>
    readonly first_name: FieldRef<"app_user", 'String'>
    readonly last_name: FieldRef<"app_user", 'String'>
    readonly email: FieldRef<"app_user", 'String'>
    readonly password: FieldRef<"app_user", 'String'>
  }
    

  // Custom InputTypes

  /**
   * app_user findUnique
   */
  export type app_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_user
     */
    select?: app_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: app_userInclude<ExtArgs> | null
    /**
     * Filter, which app_user to fetch.
     */
    where: app_userWhereUniqueInput
  }


  /**
   * app_user findUniqueOrThrow
   */
  export type app_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_user
     */
    select?: app_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: app_userInclude<ExtArgs> | null
    /**
     * Filter, which app_user to fetch.
     */
    where: app_userWhereUniqueInput
  }


  /**
   * app_user findFirst
   */
  export type app_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_user
     */
    select?: app_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: app_userInclude<ExtArgs> | null
    /**
     * Filter, which app_user to fetch.
     */
    where?: app_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_users to fetch.
     */
    orderBy?: app_userOrderByWithRelationInput | app_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_users.
     */
    cursor?: app_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_users.
     */
    distinct?: App_userScalarFieldEnum | App_userScalarFieldEnum[]
  }


  /**
   * app_user findFirstOrThrow
   */
  export type app_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_user
     */
    select?: app_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: app_userInclude<ExtArgs> | null
    /**
     * Filter, which app_user to fetch.
     */
    where?: app_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_users to fetch.
     */
    orderBy?: app_userOrderByWithRelationInput | app_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_users.
     */
    cursor?: app_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_users.
     */
    distinct?: App_userScalarFieldEnum | App_userScalarFieldEnum[]
  }


  /**
   * app_user findMany
   */
  export type app_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_user
     */
    select?: app_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: app_userInclude<ExtArgs> | null
    /**
     * Filter, which app_users to fetch.
     */
    where?: app_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_users to fetch.
     */
    orderBy?: app_userOrderByWithRelationInput | app_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_users.
     */
    cursor?: app_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_users.
     */
    skip?: number
    distinct?: App_userScalarFieldEnum | App_userScalarFieldEnum[]
  }


  /**
   * app_user create
   */
  export type app_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_user
     */
    select?: app_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: app_userInclude<ExtArgs> | null
    /**
     * The data needed to create a app_user.
     */
    data: XOR<app_userCreateInput, app_userUncheckedCreateInput>
  }


  /**
   * app_user createMany
   */
  export type app_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_users.
     */
    data: app_userCreateManyInput | app_userCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * app_user update
   */
  export type app_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_user
     */
    select?: app_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: app_userInclude<ExtArgs> | null
    /**
     * The data needed to update a app_user.
     */
    data: XOR<app_userUpdateInput, app_userUncheckedUpdateInput>
    /**
     * Choose, which app_user to update.
     */
    where: app_userWhereUniqueInput
  }


  /**
   * app_user updateMany
   */
  export type app_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_users.
     */
    data: XOR<app_userUpdateManyMutationInput, app_userUncheckedUpdateManyInput>
    /**
     * Filter which app_users to update
     */
    where?: app_userWhereInput
  }


  /**
   * app_user upsert
   */
  export type app_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_user
     */
    select?: app_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: app_userInclude<ExtArgs> | null
    /**
     * The filter to search for the app_user to update in case it exists.
     */
    where: app_userWhereUniqueInput
    /**
     * In case the app_user found by the `where` argument doesn't exist, create a new app_user with this data.
     */
    create: XOR<app_userCreateInput, app_userUncheckedCreateInput>
    /**
     * In case the app_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_userUpdateInput, app_userUncheckedUpdateInput>
  }


  /**
   * app_user delete
   */
  export type app_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_user
     */
    select?: app_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: app_userInclude<ExtArgs> | null
    /**
     * Filter which app_user to delete.
     */
    where: app_userWhereUniqueInput
  }


  /**
   * app_user deleteMany
   */
  export type app_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_users to delete
     */
    where?: app_userWhereInput
  }


  /**
   * app_user.address
   */
  export type app_user$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    where?: addressWhereInput
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    cursor?: addressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * app_user.cart
   */
  export type app_user$cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    where?: cartWhereInput
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    cursor?: cartWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }


  /**
   * app_user.checkout_session
   */
  export type app_user$checkout_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    where?: checkout_sessionWhereInput
    orderBy?: checkout_sessionOrderByWithRelationInput | checkout_sessionOrderByWithRelationInput[]
    cursor?: checkout_sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Checkout_sessionScalarFieldEnum | Checkout_sessionScalarFieldEnum[]
  }


  /**
   * app_user.order
   */
  export type app_user$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * app_user.payment_card
   */
  export type app_user$payment_cardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
    where?: payment_cardWhereInput
    orderBy?: payment_cardOrderByWithRelationInput | payment_cardOrderByWithRelationInput[]
    cursor?: payment_cardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Payment_cardScalarFieldEnum | Payment_cardScalarFieldEnum[]
  }


  /**
   * app_user without action
   */
  export type app_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_user
     */
    select?: app_userSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: app_userInclude<ExtArgs> | null
  }



  /**
   * Model cart
   */

  export type AggregateCart = {
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  export type CartAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    num_items: number | null
    total: Decimal | null
    subtotal: Decimal | null
    taxes: Decimal | null
  }

  export type CartSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    num_items: number | null
    total: Decimal | null
    subtotal: Decimal | null
    taxes: Decimal | null
  }

  export type CartMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    num_items: number | null
    total: Decimal | null
    subtotal: Decimal | null
    taxes: Decimal | null
  }

  export type CartMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    num_items: number | null
    total: Decimal | null
    subtotal: Decimal | null
    taxes: Decimal | null
  }

  export type CartCountAggregateOutputType = {
    id: number
    user_id: number
    num_items: number
    total: number
    subtotal: number
    taxes: number
    _all: number
  }


  export type CartAvgAggregateInputType = {
    id?: true
    user_id?: true
    num_items?: true
    total?: true
    subtotal?: true
    taxes?: true
  }

  export type CartSumAggregateInputType = {
    id?: true
    user_id?: true
    num_items?: true
    total?: true
    subtotal?: true
    taxes?: true
  }

  export type CartMinAggregateInputType = {
    id?: true
    user_id?: true
    num_items?: true
    total?: true
    subtotal?: true
    taxes?: true
  }

  export type CartMaxAggregateInputType = {
    id?: true
    user_id?: true
    num_items?: true
    total?: true
    subtotal?: true
    taxes?: true
  }

  export type CartCountAggregateInputType = {
    id?: true
    user_id?: true
    num_items?: true
    total?: true
    subtotal?: true
    taxes?: true
    _all?: true
  }

  export type CartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cart to aggregate.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned carts
    **/
    _count?: true | CartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CartMaxAggregateInputType
  }

  export type GetCartAggregateType<T extends CartAggregateArgs> = {
        [P in keyof T & keyof AggregateCart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart[P]>
      : GetScalarType<T[P], AggregateCart[P]>
  }




  export type cartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cartWhereInput
    orderBy?: cartOrderByWithAggregationInput | cartOrderByWithAggregationInput[]
    by: CartScalarFieldEnum[] | CartScalarFieldEnum
    having?: cartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CartCountAggregateInputType | true
    _avg?: CartAvgAggregateInputType
    _sum?: CartSumAggregateInputType
    _min?: CartMinAggregateInputType
    _max?: CartMaxAggregateInputType
  }

  export type CartGroupByOutputType = {
    id: number
    user_id: number
    num_items: number
    total: Decimal
    subtotal: Decimal
    taxes: Decimal
    _count: CartCountAggregateOutputType | null
    _avg: CartAvgAggregateOutputType | null
    _sum: CartSumAggregateOutputType | null
    _min: CartMinAggregateOutputType | null
    _max: CartMaxAggregateOutputType | null
  }

  type GetCartGroupByPayload<T extends cartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CartGroupByOutputType[P]>
            : GetScalarType<T[P], CartGroupByOutputType[P]>
        }
      >
    >


  export type cartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    num_items?: boolean
    total?: boolean
    subtotal?: boolean
    taxes?: boolean
    app_user?: boolean | app_userDefaultArgs<ExtArgs>
    cart_product?: boolean | cart$cart_productArgs<ExtArgs>
    checkout_session?: boolean | cart$checkout_sessionArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart"]>

  export type cartSelectScalar = {
    id?: boolean
    user_id?: boolean
    num_items?: boolean
    total?: boolean
    subtotal?: boolean
    taxes?: boolean
  }

  export type cartInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_user?: boolean | app_userDefaultArgs<ExtArgs>
    cart_product?: boolean | cart$cart_productArgs<ExtArgs>
    checkout_session?: boolean | cart$checkout_sessionArgs<ExtArgs>
    _count?: boolean | CartCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $cartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cart"
    objects: {
      app_user: Prisma.$app_userPayload<ExtArgs>
      cart_product: Prisma.$cart_productPayload<ExtArgs>[]
      checkout_session: Prisma.$checkout_sessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      num_items: number
      total: Prisma.Decimal
      subtotal: Prisma.Decimal
      taxes: Prisma.Decimal
    }, ExtArgs["result"]["cart"]>
    composites: {}
  }


  type cartGetPayload<S extends boolean | null | undefined | cartDefaultArgs> = $Result.GetResult<Prisma.$cartPayload, S>

  type cartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cartFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CartCountAggregateInputType | true
    }

  export interface cartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cart'], meta: { name: 'cart' } }
    /**
     * Find zero or one Cart that matches the filter.
     * @param {cartFindUniqueArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cartFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, cartFindUniqueArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cart that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {cartFindUniqueOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cartFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cartFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartFindFirstArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cartFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, cartFindFirstArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartFindFirstOrThrowArgs} args - Arguments to find a Cart
     * @example
     * // Get one Cart
     * const cart = await prisma.cart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cartFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cartFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Carts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carts
     * const carts = await prisma.cart.findMany()
     * 
     * // Get first 10 Carts
     * const carts = await prisma.cart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cartWithIdOnly = await prisma.cart.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends cartFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cartFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cart.
     * @param {cartCreateArgs} args - Arguments to create a Cart.
     * @example
     * // Create one Cart
     * const Cart = await prisma.cart.create({
     *   data: {
     *     // ... data to create a Cart
     *   }
     * })
     * 
    **/
    create<T extends cartCreateArgs<ExtArgs>>(
      args: SelectSubset<T, cartCreateArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Carts.
     *     @param {cartCreateManyArgs} args - Arguments to create many Carts.
     *     @example
     *     // Create many Carts
     *     const cart = await prisma.cart.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cartCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cartCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cart.
     * @param {cartDeleteArgs} args - Arguments to delete one Cart.
     * @example
     * // Delete one Cart
     * const Cart = await prisma.cart.delete({
     *   where: {
     *     // ... filter to delete one Cart
     *   }
     * })
     * 
    **/
    delete<T extends cartDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, cartDeleteArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cart.
     * @param {cartUpdateArgs} args - Arguments to update one Cart.
     * @example
     * // Update one Cart
     * const cart = await prisma.cart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cartUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, cartUpdateArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Carts.
     * @param {cartDeleteManyArgs} args - Arguments to filter Carts to delete.
     * @example
     * // Delete a few Carts
     * const { count } = await prisma.cart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cartDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cartDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carts
     * const cart = await prisma.cart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cartUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, cartUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cart.
     * @param {cartUpsertArgs} args - Arguments to update or create a Cart.
     * @example
     * // Update or create a Cart
     * const cart = await prisma.cart.upsert({
     *   create: {
     *     // ... data to create a Cart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart we want to update
     *   }
     * })
    **/
    upsert<T extends cartUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, cartUpsertArgs<ExtArgs>>
    ): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Carts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartCountArgs} args - Arguments to filter Carts to count.
     * @example
     * // Count the number of Carts
     * const count = await prisma.cart.count({
     *   where: {
     *     // ... the filter for the Carts we want to count
     *   }
     * })
    **/
    count<T extends cartCountArgs>(
      args?: Subset<T, cartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CartAggregateArgs>(args: Subset<T, CartAggregateArgs>): Prisma.PrismaPromise<GetCartAggregateType<T>>

    /**
     * Group by Cart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cartGroupByArgs['orderBy'] }
        : { orderBy?: cartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cart model
   */
  readonly fields: cartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    app_user<T extends app_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, app_userDefaultArgs<ExtArgs>>): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    cart_product<T extends cart$cart_productArgs<ExtArgs> = {}>(args?: Subset<T, cart$cart_productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cart_productPayload<ExtArgs>, T, 'findMany'> | Null>;

    checkout_session<T extends cart$checkout_sessionArgs<ExtArgs> = {}>(args?: Subset<T, cart$checkout_sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the cart model
   */ 
  interface cartFieldRefs {
    readonly id: FieldRef<"cart", 'Int'>
    readonly user_id: FieldRef<"cart", 'Int'>
    readonly num_items: FieldRef<"cart", 'Int'>
    readonly total: FieldRef<"cart", 'Decimal'>
    readonly subtotal: FieldRef<"cart", 'Decimal'>
    readonly taxes: FieldRef<"cart", 'Decimal'>
  }
    

  // Custom InputTypes

  /**
   * cart findUnique
   */
  export type cartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where: cartWhereUniqueInput
  }


  /**
   * cart findUniqueOrThrow
   */
  export type cartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where: cartWhereUniqueInput
  }


  /**
   * cart findFirst
   */
  export type cartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carts.
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }


  /**
   * cart findFirstOrThrow
   */
  export type cartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which cart to fetch.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for carts.
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of carts.
     */
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }


  /**
   * cart findMany
   */
  export type cartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter, which carts to fetch.
     */
    where?: cartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of carts to fetch.
     */
    orderBy?: cartOrderByWithRelationInput | cartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing carts.
     */
    cursor?: cartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` carts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` carts.
     */
    skip?: number
    distinct?: CartScalarFieldEnum | CartScalarFieldEnum[]
  }


  /**
   * cart create
   */
  export type cartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * The data needed to create a cart.
     */
    data: XOR<cartCreateInput, cartUncheckedCreateInput>
  }


  /**
   * cart createMany
   */
  export type cartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many carts.
     */
    data: cartCreateManyInput | cartCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * cart update
   */
  export type cartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * The data needed to update a cart.
     */
    data: XOR<cartUpdateInput, cartUncheckedUpdateInput>
    /**
     * Choose, which cart to update.
     */
    where: cartWhereUniqueInput
  }


  /**
   * cart updateMany
   */
  export type cartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update carts.
     */
    data: XOR<cartUpdateManyMutationInput, cartUncheckedUpdateManyInput>
    /**
     * Filter which carts to update
     */
    where?: cartWhereInput
  }


  /**
   * cart upsert
   */
  export type cartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * The filter to search for the cart to update in case it exists.
     */
    where: cartWhereUniqueInput
    /**
     * In case the cart found by the `where` argument doesn't exist, create a new cart with this data.
     */
    create: XOR<cartCreateInput, cartUncheckedCreateInput>
    /**
     * In case the cart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cartUpdateInput, cartUncheckedUpdateInput>
  }


  /**
   * cart delete
   */
  export type cartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
    /**
     * Filter which cart to delete.
     */
    where: cartWhereUniqueInput
  }


  /**
   * cart deleteMany
   */
  export type cartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which carts to delete
     */
    where?: cartWhereInput
  }


  /**
   * cart.cart_product
   */
  export type cart$cart_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
    where?: cart_productWhereInput
    orderBy?: cart_productOrderByWithRelationInput | cart_productOrderByWithRelationInput[]
    cursor?: cart_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cart_productScalarFieldEnum | Cart_productScalarFieldEnum[]
  }


  /**
   * cart.checkout_session
   */
  export type cart$checkout_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    where?: checkout_sessionWhereInput
    orderBy?: checkout_sessionOrderByWithRelationInput | checkout_sessionOrderByWithRelationInput[]
    cursor?: checkout_sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Checkout_sessionScalarFieldEnum | Checkout_sessionScalarFieldEnum[]
  }


  /**
   * cart without action
   */
  export type cartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart
     */
    select?: cartSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cartInclude<ExtArgs> | null
  }



  /**
   * Model cart_product
   */

  export type AggregateCart_product = {
    _count: Cart_productCountAggregateOutputType | null
    _avg: Cart_productAvgAggregateOutputType | null
    _sum: Cart_productSumAggregateOutputType | null
    _min: Cart_productMinAggregateOutputType | null
    _max: Cart_productMaxAggregateOutputType | null
  }

  export type Cart_productAvgAggregateOutputType = {
    product_id: number | null
    cart_id: number | null
    quantity: number | null
  }

  export type Cart_productSumAggregateOutputType = {
    product_id: number | null
    cart_id: number | null
    quantity: number | null
  }

  export type Cart_productMinAggregateOutputType = {
    product_id: number | null
    cart_id: number | null
    quantity: number | null
  }

  export type Cart_productMaxAggregateOutputType = {
    product_id: number | null
    cart_id: number | null
    quantity: number | null
  }

  export type Cart_productCountAggregateOutputType = {
    product_id: number
    cart_id: number
    quantity: number
    _all: number
  }


  export type Cart_productAvgAggregateInputType = {
    product_id?: true
    cart_id?: true
    quantity?: true
  }

  export type Cart_productSumAggregateInputType = {
    product_id?: true
    cart_id?: true
    quantity?: true
  }

  export type Cart_productMinAggregateInputType = {
    product_id?: true
    cart_id?: true
    quantity?: true
  }

  export type Cart_productMaxAggregateInputType = {
    product_id?: true
    cart_id?: true
    quantity?: true
  }

  export type Cart_productCountAggregateInputType = {
    product_id?: true
    cart_id?: true
    quantity?: true
    _all?: true
  }

  export type Cart_productAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cart_product to aggregate.
     */
    where?: cart_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cart_products to fetch.
     */
    orderBy?: cart_productOrderByWithRelationInput | cart_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cart_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cart_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cart_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cart_products
    **/
    _count?: true | Cart_productCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cart_productAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cart_productSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cart_productMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cart_productMaxAggregateInputType
  }

  export type GetCart_productAggregateType<T extends Cart_productAggregateArgs> = {
        [P in keyof T & keyof AggregateCart_product]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCart_product[P]>
      : GetScalarType<T[P], AggregateCart_product[P]>
  }




  export type cart_productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cart_productWhereInput
    orderBy?: cart_productOrderByWithAggregationInput | cart_productOrderByWithAggregationInput[]
    by: Cart_productScalarFieldEnum[] | Cart_productScalarFieldEnum
    having?: cart_productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cart_productCountAggregateInputType | true
    _avg?: Cart_productAvgAggregateInputType
    _sum?: Cart_productSumAggregateInputType
    _min?: Cart_productMinAggregateInputType
    _max?: Cart_productMaxAggregateInputType
  }

  export type Cart_productGroupByOutputType = {
    product_id: number
    cart_id: number
    quantity: number
    _count: Cart_productCountAggregateOutputType | null
    _avg: Cart_productAvgAggregateOutputType | null
    _sum: Cart_productSumAggregateOutputType | null
    _min: Cart_productMinAggregateOutputType | null
    _max: Cart_productMaxAggregateOutputType | null
  }

  type GetCart_productGroupByPayload<T extends cart_productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cart_productGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cart_productGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cart_productGroupByOutputType[P]>
            : GetScalarType<T[P], Cart_productGroupByOutputType[P]>
        }
      >
    >


  export type cart_productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    product_id?: boolean
    cart_id?: boolean
    quantity?: boolean
    cart?: boolean | cartDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cart_product"]>

  export type cart_productSelectScalar = {
    product_id?: boolean
    cart_id?: boolean
    quantity?: boolean
  }

  export type cart_productInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | cartDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }


  export type $cart_productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cart_product"
    objects: {
      cart: Prisma.$cartPayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      product_id: number
      cart_id: number
      quantity: number
    }, ExtArgs["result"]["cart_product"]>
    composites: {}
  }


  type cart_productGetPayload<S extends boolean | null | undefined | cart_productDefaultArgs> = $Result.GetResult<Prisma.$cart_productPayload, S>

  type cart_productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<cart_productFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Cart_productCountAggregateInputType | true
    }

  export interface cart_productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cart_product'], meta: { name: 'cart_product' } }
    /**
     * Find zero or one Cart_product that matches the filter.
     * @param {cart_productFindUniqueArgs} args - Arguments to find a Cart_product
     * @example
     * // Get one Cart_product
     * const cart_product = await prisma.cart_product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends cart_productFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, cart_productFindUniqueArgs<ExtArgs>>
    ): Prisma__cart_productClient<$Result.GetResult<Prisma.$cart_productPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cart_product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {cart_productFindUniqueOrThrowArgs} args - Arguments to find a Cart_product
     * @example
     * // Get one Cart_product
     * const cart_product = await prisma.cart_product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends cart_productFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cart_productFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__cart_productClient<$Result.GetResult<Prisma.$cart_productPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cart_product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_productFindFirstArgs} args - Arguments to find a Cart_product
     * @example
     * // Get one Cart_product
     * const cart_product = await prisma.cart_product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends cart_productFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, cart_productFindFirstArgs<ExtArgs>>
    ): Prisma__cart_productClient<$Result.GetResult<Prisma.$cart_productPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cart_product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_productFindFirstOrThrowArgs} args - Arguments to find a Cart_product
     * @example
     * // Get one Cart_product
     * const cart_product = await prisma.cart_product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends cart_productFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, cart_productFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__cart_productClient<$Result.GetResult<Prisma.$cart_productPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cart_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cart_products
     * const cart_products = await prisma.cart_product.findMany()
     * 
     * // Get first 10 Cart_products
     * const cart_products = await prisma.cart_product.findMany({ take: 10 })
     * 
     * // Only select the `product_id`
     * const cart_productWithProduct_idOnly = await prisma.cart_product.findMany({ select: { product_id: true } })
     * 
    **/
    findMany<T extends cart_productFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cart_productFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cart_productPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cart_product.
     * @param {cart_productCreateArgs} args - Arguments to create a Cart_product.
     * @example
     * // Create one Cart_product
     * const Cart_product = await prisma.cart_product.create({
     *   data: {
     *     // ... data to create a Cart_product
     *   }
     * })
     * 
    **/
    create<T extends cart_productCreateArgs<ExtArgs>>(
      args: SelectSubset<T, cart_productCreateArgs<ExtArgs>>
    ): Prisma__cart_productClient<$Result.GetResult<Prisma.$cart_productPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cart_products.
     *     @param {cart_productCreateManyArgs} args - Arguments to create many Cart_products.
     *     @example
     *     // Create many Cart_products
     *     const cart_product = await prisma.cart_product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends cart_productCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cart_productCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cart_product.
     * @param {cart_productDeleteArgs} args - Arguments to delete one Cart_product.
     * @example
     * // Delete one Cart_product
     * const Cart_product = await prisma.cart_product.delete({
     *   where: {
     *     // ... filter to delete one Cart_product
     *   }
     * })
     * 
    **/
    delete<T extends cart_productDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, cart_productDeleteArgs<ExtArgs>>
    ): Prisma__cart_productClient<$Result.GetResult<Prisma.$cart_productPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cart_product.
     * @param {cart_productUpdateArgs} args - Arguments to update one Cart_product.
     * @example
     * // Update one Cart_product
     * const cart_product = await prisma.cart_product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends cart_productUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, cart_productUpdateArgs<ExtArgs>>
    ): Prisma__cart_productClient<$Result.GetResult<Prisma.$cart_productPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cart_products.
     * @param {cart_productDeleteManyArgs} args - Arguments to filter Cart_products to delete.
     * @example
     * // Delete a few Cart_products
     * const { count } = await prisma.cart_product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends cart_productDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, cart_productDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cart_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cart_products
     * const cart_product = await prisma.cart_product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends cart_productUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, cart_productUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cart_product.
     * @param {cart_productUpsertArgs} args - Arguments to update or create a Cart_product.
     * @example
     * // Update or create a Cart_product
     * const cart_product = await prisma.cart_product.upsert({
     *   create: {
     *     // ... data to create a Cart_product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cart_product we want to update
     *   }
     * })
    **/
    upsert<T extends cart_productUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, cart_productUpsertArgs<ExtArgs>>
    ): Prisma__cart_productClient<$Result.GetResult<Prisma.$cart_productPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Cart_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_productCountArgs} args - Arguments to filter Cart_products to count.
     * @example
     * // Count the number of Cart_products
     * const count = await prisma.cart_product.count({
     *   where: {
     *     // ... the filter for the Cart_products we want to count
     *   }
     * })
    **/
    count<T extends cart_productCountArgs>(
      args?: Subset<T, cart_productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cart_productCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cart_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cart_productAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cart_productAggregateArgs>(args: Subset<T, Cart_productAggregateArgs>): Prisma.PrismaPromise<GetCart_productAggregateType<T>>

    /**
     * Group by Cart_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cart_productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cart_productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cart_productGroupByArgs['orderBy'] }
        : { orderBy?: cart_productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cart_productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCart_productGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cart_product model
   */
  readonly fields: cart_productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cart_product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cart_productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cart<T extends cartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cartDefaultArgs<ExtArgs>>): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the cart_product model
   */ 
  interface cart_productFieldRefs {
    readonly product_id: FieldRef<"cart_product", 'Int'>
    readonly cart_id: FieldRef<"cart_product", 'Int'>
    readonly quantity: FieldRef<"cart_product", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * cart_product findUnique
   */
  export type cart_productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
    /**
     * Filter, which cart_product to fetch.
     */
    where: cart_productWhereUniqueInput
  }


  /**
   * cart_product findUniqueOrThrow
   */
  export type cart_productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
    /**
     * Filter, which cart_product to fetch.
     */
    where: cart_productWhereUniqueInput
  }


  /**
   * cart_product findFirst
   */
  export type cart_productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
    /**
     * Filter, which cart_product to fetch.
     */
    where?: cart_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cart_products to fetch.
     */
    orderBy?: cart_productOrderByWithRelationInput | cart_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cart_products.
     */
    cursor?: cart_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cart_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cart_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cart_products.
     */
    distinct?: Cart_productScalarFieldEnum | Cart_productScalarFieldEnum[]
  }


  /**
   * cart_product findFirstOrThrow
   */
  export type cart_productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
    /**
     * Filter, which cart_product to fetch.
     */
    where?: cart_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cart_products to fetch.
     */
    orderBy?: cart_productOrderByWithRelationInput | cart_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cart_products.
     */
    cursor?: cart_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cart_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cart_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cart_products.
     */
    distinct?: Cart_productScalarFieldEnum | Cart_productScalarFieldEnum[]
  }


  /**
   * cart_product findMany
   */
  export type cart_productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
    /**
     * Filter, which cart_products to fetch.
     */
    where?: cart_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cart_products to fetch.
     */
    orderBy?: cart_productOrderByWithRelationInput | cart_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cart_products.
     */
    cursor?: cart_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cart_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cart_products.
     */
    skip?: number
    distinct?: Cart_productScalarFieldEnum | Cart_productScalarFieldEnum[]
  }


  /**
   * cart_product create
   */
  export type cart_productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
    /**
     * The data needed to create a cart_product.
     */
    data: XOR<cart_productCreateInput, cart_productUncheckedCreateInput>
  }


  /**
   * cart_product createMany
   */
  export type cart_productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cart_products.
     */
    data: cart_productCreateManyInput | cart_productCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * cart_product update
   */
  export type cart_productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
    /**
     * The data needed to update a cart_product.
     */
    data: XOR<cart_productUpdateInput, cart_productUncheckedUpdateInput>
    /**
     * Choose, which cart_product to update.
     */
    where: cart_productWhereUniqueInput
  }


  /**
   * cart_product updateMany
   */
  export type cart_productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cart_products.
     */
    data: XOR<cart_productUpdateManyMutationInput, cart_productUncheckedUpdateManyInput>
    /**
     * Filter which cart_products to update
     */
    where?: cart_productWhereInput
  }


  /**
   * cart_product upsert
   */
  export type cart_productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
    /**
     * The filter to search for the cart_product to update in case it exists.
     */
    where: cart_productWhereUniqueInput
    /**
     * In case the cart_product found by the `where` argument doesn't exist, create a new cart_product with this data.
     */
    create: XOR<cart_productCreateInput, cart_productUncheckedCreateInput>
    /**
     * In case the cart_product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cart_productUpdateInput, cart_productUncheckedUpdateInput>
  }


  /**
   * cart_product delete
   */
  export type cart_productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
    /**
     * Filter which cart_product to delete.
     */
    where: cart_productWhereUniqueInput
  }


  /**
   * cart_product deleteMany
   */
  export type cart_productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cart_products to delete
     */
    where?: cart_productWhereInput
  }


  /**
   * cart_product without action
   */
  export type cart_productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
  }



  /**
   * Model order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    total: Decimal | null
    subtotal: Decimal | null
    taxes: Decimal | null
    num_items: number | null
    payment_card_id: number | null
    shipping_address_id: number | null
    billing_address_id: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    total: Decimal | null
    subtotal: Decimal | null
    taxes: Decimal | null
    num_items: number | null
    payment_card_id: number | null
    shipping_address_id: number | null
    billing_address_id: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    order_date: Date | null
    total: Decimal | null
    subtotal: Decimal | null
    taxes: Decimal | null
    num_items: number | null
    payment_card_id: number | null
    shipping_address_id: number | null
    billing_address_id: number | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    order_date: Date | null
    total: Decimal | null
    subtotal: Decimal | null
    taxes: Decimal | null
    num_items: number | null
    payment_card_id: number | null
    shipping_address_id: number | null
    billing_address_id: number | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    user_id: number
    order_date: number
    total: number
    subtotal: number
    taxes: number
    num_items: number
    payment_card_id: number
    shipping_address_id: number
    billing_address_id: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    user_id?: true
    total?: true
    subtotal?: true
    taxes?: true
    num_items?: true
    payment_card_id?: true
    shipping_address_id?: true
    billing_address_id?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    user_id?: true
    total?: true
    subtotal?: true
    taxes?: true
    num_items?: true
    payment_card_id?: true
    shipping_address_id?: true
    billing_address_id?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    user_id?: true
    order_date?: true
    total?: true
    subtotal?: true
    taxes?: true
    num_items?: true
    payment_card_id?: true
    shipping_address_id?: true
    billing_address_id?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    user_id?: true
    order_date?: true
    total?: true
    subtotal?: true
    taxes?: true
    num_items?: true
    payment_card_id?: true
    shipping_address_id?: true
    billing_address_id?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    user_id?: true
    order_date?: true
    total?: true
    subtotal?: true
    taxes?: true
    num_items?: true
    payment_card_id?: true
    shipping_address_id?: true
    billing_address_id?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order to aggregate.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type orderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: orderWhereInput
    orderBy?: orderOrderByWithAggregationInput | orderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: orderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    user_id: number
    order_date: Date
    total: Decimal
    subtotal: Decimal
    taxes: Decimal
    num_items: number
    payment_card_id: number
    shipping_address_id: number
    billing_address_id: number
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends orderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type orderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    order_date?: boolean
    total?: boolean
    subtotal?: boolean
    taxes?: boolean
    num_items?: boolean
    payment_card_id?: boolean
    shipping_address_id?: boolean
    billing_address_id?: boolean
    address_order_billing_address_idToaddress?: boolean | addressDefaultArgs<ExtArgs>
    payment_card?: boolean | payment_cardDefaultArgs<ExtArgs>
    address_order_shipping_address_idToaddress?: boolean | addressDefaultArgs<ExtArgs>
    app_user?: boolean | app_userDefaultArgs<ExtArgs>
    order_product?: boolean | order$order_productArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type orderSelectScalar = {
    id?: boolean
    user_id?: boolean
    order_date?: boolean
    total?: boolean
    subtotal?: boolean
    taxes?: boolean
    num_items?: boolean
    payment_card_id?: boolean
    shipping_address_id?: boolean
    billing_address_id?: boolean
  }

  export type orderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    address_order_billing_address_idToaddress?: boolean | addressDefaultArgs<ExtArgs>
    payment_card?: boolean | payment_cardDefaultArgs<ExtArgs>
    address_order_shipping_address_idToaddress?: boolean | addressDefaultArgs<ExtArgs>
    app_user?: boolean | app_userDefaultArgs<ExtArgs>
    order_product?: boolean | order$order_productArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $orderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order"
    objects: {
      address_order_billing_address_idToaddress: Prisma.$addressPayload<ExtArgs>
      payment_card: Prisma.$payment_cardPayload<ExtArgs>
      address_order_shipping_address_idToaddress: Prisma.$addressPayload<ExtArgs>
      app_user: Prisma.$app_userPayload<ExtArgs>
      order_product: Prisma.$order_productPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      order_date: Date
      total: Prisma.Decimal
      subtotal: Prisma.Decimal
      taxes: Prisma.Decimal
      num_items: number
      payment_card_id: number
      shipping_address_id: number
      billing_address_id: number
    }, ExtArgs["result"]["order"]>
    composites: {}
  }


  type orderGetPayload<S extends boolean | null | undefined | orderDefaultArgs> = $Result.GetResult<Prisma.$orderPayload, S>

  type orderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<orderFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: OrderCountAggregateInputType | true
    }

  export interface orderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order'], meta: { name: 'order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {orderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends orderFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, orderFindUniqueArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {orderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends orderFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends orderFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindFirstArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends orderFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends orderFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order.
     * @param {orderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
    **/
    create<T extends orderCreateArgs<ExtArgs>>(
      args: SelectSubset<T, orderCreateArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Orders.
     *     @param {orderCreateManyArgs} args - Arguments to create many Orders.
     *     @example
     *     // Create many Orders
     *     const order = await prisma.order.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends orderCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order.
     * @param {orderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
    **/
    delete<T extends orderDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, orderDeleteArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order.
     * @param {orderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends orderUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpdateArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {orderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends orderDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, orderDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends orderUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {orderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
    **/
    upsert<T extends orderUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, orderUpsertArgs<ExtArgs>>
    ): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends orderCountArgs>(
      args?: Subset<T, orderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {orderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends orderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: orderGroupByArgs['orderBy'] }
        : { orderBy?: orderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, orderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order model
   */
  readonly fields: orderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__orderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    address_order_billing_address_idToaddress<T extends addressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, addressDefaultArgs<ExtArgs>>): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    payment_card<T extends payment_cardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, payment_cardDefaultArgs<ExtArgs>>): Prisma__payment_cardClient<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    address_order_shipping_address_idToaddress<T extends addressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, addressDefaultArgs<ExtArgs>>): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    app_user<T extends app_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, app_userDefaultArgs<ExtArgs>>): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    order_product<T extends order$order_productArgs<ExtArgs> = {}>(args?: Subset<T, order$order_productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the order model
   */ 
  interface orderFieldRefs {
    readonly id: FieldRef<"order", 'Int'>
    readonly user_id: FieldRef<"order", 'Int'>
    readonly order_date: FieldRef<"order", 'DateTime'>
    readonly total: FieldRef<"order", 'Decimal'>
    readonly subtotal: FieldRef<"order", 'Decimal'>
    readonly taxes: FieldRef<"order", 'Decimal'>
    readonly num_items: FieldRef<"order", 'Int'>
    readonly payment_card_id: FieldRef<"order", 'Int'>
    readonly shipping_address_id: FieldRef<"order", 'Int'>
    readonly billing_address_id: FieldRef<"order", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * order findUnique
   */
  export type orderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order findUniqueOrThrow
   */
  export type orderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order findFirst
   */
  export type orderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * order findFirstOrThrow
   */
  export type orderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which order to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * order findMany
   */
  export type orderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter, which orders to fetch.
     */
    where?: orderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of orders to fetch.
     */
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing orders.
     */
    cursor?: orderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * order create
   */
  export type orderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The data needed to create a order.
     */
    data: XOR<orderCreateInput, orderUncheckedCreateInput>
  }


  /**
   * order createMany
   */
  export type orderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many orders.
     */
    data: orderCreateManyInput | orderCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * order update
   */
  export type orderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The data needed to update a order.
     */
    data: XOR<orderUpdateInput, orderUncheckedUpdateInput>
    /**
     * Choose, which order to update.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order updateMany
   */
  export type orderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update orders.
     */
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyInput>
    /**
     * Filter which orders to update
     */
    where?: orderWhereInput
  }


  /**
   * order upsert
   */
  export type orderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * The filter to search for the order to update in case it exists.
     */
    where: orderWhereUniqueInput
    /**
     * In case the order found by the `where` argument doesn't exist, create a new order with this data.
     */
    create: XOR<orderCreateInput, orderUncheckedCreateInput>
    /**
     * In case the order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<orderUpdateInput, orderUncheckedUpdateInput>
  }


  /**
   * order delete
   */
  export type orderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    /**
     * Filter which order to delete.
     */
    where: orderWhereUniqueInput
  }


  /**
   * order deleteMany
   */
  export type orderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which orders to delete
     */
    where?: orderWhereInput
  }


  /**
   * order.order_product
   */
  export type order$order_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    where?: order_productWhereInput
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    cursor?: order_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * order without action
   */
  export type orderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
  }



  /**
   * Model order_product
   */

  export type AggregateOrder_product = {
    _count: Order_productCountAggregateOutputType | null
    _avg: Order_productAvgAggregateOutputType | null
    _sum: Order_productSumAggregateOutputType | null
    _min: Order_productMinAggregateOutputType | null
    _max: Order_productMaxAggregateOutputType | null
  }

  export type Order_productAvgAggregateOutputType = {
    order_id: number | null
    product_id: number | null
    quantity: number | null
  }

  export type Order_productSumAggregateOutputType = {
    order_id: number | null
    product_id: number | null
    quantity: number | null
  }

  export type Order_productMinAggregateOutputType = {
    order_id: number | null
    product_id: number | null
    quantity: number | null
  }

  export type Order_productMaxAggregateOutputType = {
    order_id: number | null
    product_id: number | null
    quantity: number | null
  }

  export type Order_productCountAggregateOutputType = {
    order_id: number
    product_id: number
    quantity: number
    _all: number
  }


  export type Order_productAvgAggregateInputType = {
    order_id?: true
    product_id?: true
    quantity?: true
  }

  export type Order_productSumAggregateInputType = {
    order_id?: true
    product_id?: true
    quantity?: true
  }

  export type Order_productMinAggregateInputType = {
    order_id?: true
    product_id?: true
    quantity?: true
  }

  export type Order_productMaxAggregateInputType = {
    order_id?: true
    product_id?: true
    quantity?: true
  }

  export type Order_productCountAggregateInputType = {
    order_id?: true
    product_id?: true
    quantity?: true
    _all?: true
  }

  export type Order_productAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_product to aggregate.
     */
    where?: order_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_products to fetch.
     */
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: order_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned order_products
    **/
    _count?: true | Order_productCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Order_productAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Order_productSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Order_productMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Order_productMaxAggregateInputType
  }

  export type GetOrder_productAggregateType<T extends Order_productAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder_product]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder_product[P]>
      : GetScalarType<T[P], AggregateOrder_product[P]>
  }




  export type order_productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: order_productWhereInput
    orderBy?: order_productOrderByWithAggregationInput | order_productOrderByWithAggregationInput[]
    by: Order_productScalarFieldEnum[] | Order_productScalarFieldEnum
    having?: order_productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Order_productCountAggregateInputType | true
    _avg?: Order_productAvgAggregateInputType
    _sum?: Order_productSumAggregateInputType
    _min?: Order_productMinAggregateInputType
    _max?: Order_productMaxAggregateInputType
  }

  export type Order_productGroupByOutputType = {
    order_id: number
    product_id: number
    quantity: number
    _count: Order_productCountAggregateOutputType | null
    _avg: Order_productAvgAggregateOutputType | null
    _sum: Order_productSumAggregateOutputType | null
    _min: Order_productMinAggregateOutputType | null
    _max: Order_productMaxAggregateOutputType | null
  }

  type GetOrder_productGroupByPayload<T extends order_productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Order_productGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Order_productGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Order_productGroupByOutputType[P]>
            : GetScalarType<T[P], Order_productGroupByOutputType[P]>
        }
      >
    >


  export type order_productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    product_id?: boolean
    quantity?: boolean
    order?: boolean | orderDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order_product"]>

  export type order_productSelectScalar = {
    order_id?: boolean
    product_id?: boolean
    quantity?: boolean
  }

  export type order_productInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | orderDefaultArgs<ExtArgs>
    product?: boolean | productDefaultArgs<ExtArgs>
  }


  export type $order_productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "order_product"
    objects: {
      order: Prisma.$orderPayload<ExtArgs>
      product: Prisma.$productPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      order_id: number
      product_id: number
      quantity: number
    }, ExtArgs["result"]["order_product"]>
    composites: {}
  }


  type order_productGetPayload<S extends boolean | null | undefined | order_productDefaultArgs> = $Result.GetResult<Prisma.$order_productPayload, S>

  type order_productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<order_productFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Order_productCountAggregateInputType | true
    }

  export interface order_productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['order_product'], meta: { name: 'order_product' } }
    /**
     * Find zero or one Order_product that matches the filter.
     * @param {order_productFindUniqueArgs} args - Arguments to find a Order_product
     * @example
     * // Get one Order_product
     * const order_product = await prisma.order_product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends order_productFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, order_productFindUniqueArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Order_product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {order_productFindUniqueOrThrowArgs} args - Arguments to find a Order_product
     * @example
     * // Get one Order_product
     * const order_product = await prisma.order_product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends order_productFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Order_product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productFindFirstArgs} args - Arguments to find a Order_product
     * @example
     * // Get one Order_product
     * const order_product = await prisma.order_product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends order_productFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productFindFirstArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Order_product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productFindFirstOrThrowArgs} args - Arguments to find a Order_product
     * @example
     * // Get one Order_product
     * const order_product = await prisma.order_product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends order_productFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Order_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Order_products
     * const order_products = await prisma.order_product.findMany()
     * 
     * // Get first 10 Order_products
     * const order_products = await prisma.order_product.findMany({ take: 10 })
     * 
     * // Only select the `order_id`
     * const order_productWithOrder_idOnly = await prisma.order_product.findMany({ select: { order_id: true } })
     * 
    **/
    findMany<T extends order_productFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Order_product.
     * @param {order_productCreateArgs} args - Arguments to create a Order_product.
     * @example
     * // Create one Order_product
     * const Order_product = await prisma.order_product.create({
     *   data: {
     *     // ... data to create a Order_product
     *   }
     * })
     * 
    **/
    create<T extends order_productCreateArgs<ExtArgs>>(
      args: SelectSubset<T, order_productCreateArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Order_products.
     *     @param {order_productCreateManyArgs} args - Arguments to create many Order_products.
     *     @example
     *     // Create many Order_products
     *     const order_product = await prisma.order_product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends order_productCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Order_product.
     * @param {order_productDeleteArgs} args - Arguments to delete one Order_product.
     * @example
     * // Delete one Order_product
     * const Order_product = await prisma.order_product.delete({
     *   where: {
     *     // ... filter to delete one Order_product
     *   }
     * })
     * 
    **/
    delete<T extends order_productDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, order_productDeleteArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Order_product.
     * @param {order_productUpdateArgs} args - Arguments to update one Order_product.
     * @example
     * // Update one Order_product
     * const order_product = await prisma.order_product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends order_productUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, order_productUpdateArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Order_products.
     * @param {order_productDeleteManyArgs} args - Arguments to filter Order_products to delete.
     * @example
     * // Delete a few Order_products
     * const { count } = await prisma.order_product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends order_productDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, order_productDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Order_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Order_products
     * const order_product = await prisma.order_product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends order_productUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, order_productUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order_product.
     * @param {order_productUpsertArgs} args - Arguments to update or create a Order_product.
     * @example
     * // Update or create a Order_product
     * const order_product = await prisma.order_product.upsert({
     *   create: {
     *     // ... data to create a Order_product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order_product we want to update
     *   }
     * })
    **/
    upsert<T extends order_productUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, order_productUpsertArgs<ExtArgs>>
    ): Prisma__order_productClient<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Order_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productCountArgs} args - Arguments to filter Order_products to count.
     * @example
     * // Count the number of Order_products
     * const count = await prisma.order_product.count({
     *   where: {
     *     // ... the filter for the Order_products we want to count
     *   }
     * })
    **/
    count<T extends order_productCountArgs>(
      args?: Subset<T, order_productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Order_productCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Order_productAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Order_productAggregateArgs>(args: Subset<T, Order_productAggregateArgs>): Prisma.PrismaPromise<GetOrder_productAggregateType<T>>

    /**
     * Group by Order_product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {order_productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends order_productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: order_productGroupByArgs['orderBy'] }
        : { orderBy?: order_productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, order_productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrder_productGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the order_product model
   */
  readonly fields: order_productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for order_product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__order_productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    order<T extends orderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, orderDefaultArgs<ExtArgs>>): Prisma__orderClient<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    product<T extends productDefaultArgs<ExtArgs> = {}>(args?: Subset<T, productDefaultArgs<ExtArgs>>): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the order_product model
   */ 
  interface order_productFieldRefs {
    readonly order_id: FieldRef<"order_product", 'Int'>
    readonly product_id: FieldRef<"order_product", 'Int'>
    readonly quantity: FieldRef<"order_product", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * order_product findUnique
   */
  export type order_productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter, which order_product to fetch.
     */
    where: order_productWhereUniqueInput
  }


  /**
   * order_product findUniqueOrThrow
   */
  export type order_productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter, which order_product to fetch.
     */
    where: order_productWhereUniqueInput
  }


  /**
   * order_product findFirst
   */
  export type order_productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter, which order_product to fetch.
     */
    where?: order_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_products to fetch.
     */
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_products.
     */
    cursor?: order_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_products.
     */
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * order_product findFirstOrThrow
   */
  export type order_productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter, which order_product to fetch.
     */
    where?: order_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_products to fetch.
     */
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for order_products.
     */
    cursor?: order_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of order_products.
     */
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * order_product findMany
   */
  export type order_productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter, which order_products to fetch.
     */
    where?: order_productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of order_products to fetch.
     */
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing order_products.
     */
    cursor?: order_productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` order_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` order_products.
     */
    skip?: number
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * order_product create
   */
  export type order_productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * The data needed to create a order_product.
     */
    data: XOR<order_productCreateInput, order_productUncheckedCreateInput>
  }


  /**
   * order_product createMany
   */
  export type order_productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many order_products.
     */
    data: order_productCreateManyInput | order_productCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * order_product update
   */
  export type order_productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * The data needed to update a order_product.
     */
    data: XOR<order_productUpdateInput, order_productUncheckedUpdateInput>
    /**
     * Choose, which order_product to update.
     */
    where: order_productWhereUniqueInput
  }


  /**
   * order_product updateMany
   */
  export type order_productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update order_products.
     */
    data: XOR<order_productUpdateManyMutationInput, order_productUncheckedUpdateManyInput>
    /**
     * Filter which order_products to update
     */
    where?: order_productWhereInput
  }


  /**
   * order_product upsert
   */
  export type order_productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * The filter to search for the order_product to update in case it exists.
     */
    where: order_productWhereUniqueInput
    /**
     * In case the order_product found by the `where` argument doesn't exist, create a new order_product with this data.
     */
    create: XOR<order_productCreateInput, order_productUncheckedCreateInput>
    /**
     * In case the order_product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<order_productUpdateInput, order_productUncheckedUpdateInput>
  }


  /**
   * order_product delete
   */
  export type order_productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    /**
     * Filter which order_product to delete.
     */
    where: order_productWhereUniqueInput
  }


  /**
   * order_product deleteMany
   */
  export type order_productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which order_products to delete
     */
    where?: order_productWhereInput
  }


  /**
   * order_product without action
   */
  export type order_productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
  }



  /**
   * Model product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    inventory: number | null
    price: Decimal | null
    total_sold: number | null
    discount_percent: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    inventory: number | null
    price: Decimal | null
    total_sold: number | null
    discount_percent: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    inventory: number | null
    price: Decimal | null
    category_code: string | null
    discount_type: string | null
    total_sold: number | null
    img_filename: string | null
    discount_percent: number | null
    item_code: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    inventory: number | null
    price: Decimal | null
    category_code: string | null
    discount_type: string | null
    total_sold: number | null
    img_filename: string | null
    discount_percent: number | null
    item_code: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    inventory: number
    price: number
    category_code: number
    discount_type: number
    total_sold: number
    img_filename: number
    discount_percent: number
    item_code: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    inventory?: true
    price?: true
    total_sold?: true
    discount_percent?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    inventory?: true
    price?: true
    total_sold?: true
    discount_percent?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    inventory?: true
    price?: true
    category_code?: true
    discount_type?: true
    total_sold?: true
    img_filename?: true
    discount_percent?: true
    item_code?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    inventory?: true
    price?: true
    category_code?: true
    discount_type?: true
    total_sold?: true
    img_filename?: true
    discount_percent?: true
    item_code?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    inventory?: true
    price?: true
    category_code?: true
    discount_type?: true
    total_sold?: true
    img_filename?: true
    discount_percent?: true
    item_code?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which product to aggregate.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type productGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productWhereInput
    orderBy?: productOrderByWithAggregationInput | productOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: productScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    description: string
    inventory: number
    price: Decimal
    category_code: string
    discount_type: string
    total_sold: number
    img_filename: string
    discount_percent: number
    item_code: string
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends productGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type productSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    inventory?: boolean
    price?: boolean
    category_code?: boolean
    discount_type?: boolean
    total_sold?: boolean
    img_filename?: boolean
    discount_percent?: boolean
    item_code?: boolean
    cart_product?: boolean | product$cart_productArgs<ExtArgs>
    order_product?: boolean | product$order_productArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type productSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    inventory?: boolean
    price?: boolean
    category_code?: boolean
    discount_type?: boolean
    total_sold?: boolean
    img_filename?: boolean
    discount_percent?: boolean
    item_code?: boolean
  }

  export type productInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart_product?: boolean | product$cart_productArgs<ExtArgs>
    order_product?: boolean | product$order_productArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $productPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "product"
    objects: {
      cart_product: Prisma.$cart_productPayload<ExtArgs>[]
      order_product: Prisma.$order_productPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      inventory: number
      price: Prisma.Decimal
      category_code: string
      discount_type: string
      total_sold: number
      img_filename: string
      discount_percent: number
      item_code: string
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type productGetPayload<S extends boolean | null | undefined | productDefaultArgs> = $Result.GetResult<Prisma.$productPayload, S>

  type productCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<productFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProductCountAggregateInputType | true
    }

  export interface productDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['product'], meta: { name: 'product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {productFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends productFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, productFindUniqueArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {productFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends productFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends productFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindFirstArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends productFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends productFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {productCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends productCreateArgs<ExtArgs>>(
      args: SelectSubset<T, productCreateArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {productCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends productCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {productDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends productDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, productDeleteArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {productUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends productUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {productDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends productDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, productDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends productUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, productUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {productUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends productUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, productUpsertArgs<ExtArgs>>
    ): Prisma__productClient<$Result.GetResult<Prisma.$productPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productCountArgs>(
      args?: Subset<T, productCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productGroupByArgs['orderBy'] }
        : { orderBy?: productGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the product model
   */
  readonly fields: productFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cart_product<T extends product$cart_productArgs<ExtArgs> = {}>(args?: Subset<T, product$cart_productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cart_productPayload<ExtArgs>, T, 'findMany'> | Null>;

    order_product<T extends product$order_productArgs<ExtArgs> = {}>(args?: Subset<T, product$order_productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$order_productPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the product model
   */ 
  interface productFieldRefs {
    readonly id: FieldRef<"product", 'Int'>
    readonly name: FieldRef<"product", 'String'>
    readonly description: FieldRef<"product", 'String'>
    readonly inventory: FieldRef<"product", 'Int'>
    readonly price: FieldRef<"product", 'Decimal'>
    readonly category_code: FieldRef<"product", 'String'>
    readonly discount_type: FieldRef<"product", 'String'>
    readonly total_sold: FieldRef<"product", 'Int'>
    readonly img_filename: FieldRef<"product", 'String'>
    readonly discount_percent: FieldRef<"product", 'Int'>
    readonly item_code: FieldRef<"product", 'String'>
  }
    

  // Custom InputTypes

  /**
   * product findUnique
   */
  export type productFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product findUniqueOrThrow
   */
  export type productFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where: productWhereUniqueInput
  }


  /**
   * product findFirst
   */
  export type productFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product findFirstOrThrow
   */
  export type productFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which product to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product findMany
   */
  export type productFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productOrderByWithRelationInput | productOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * product create
   */
  export type productCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to create a product.
     */
    data: XOR<productCreateInput, productUncheckedCreateInput>
  }


  /**
   * product createMany
   */
  export type productCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productCreateManyInput | productCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * product update
   */
  export type productUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The data needed to update a product.
     */
    data: XOR<productUpdateInput, productUncheckedUpdateInput>
    /**
     * Choose, which product to update.
     */
    where: productWhereUniqueInput
  }


  /**
   * product updateMany
   */
  export type productUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productUpdateManyMutationInput, productUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productWhereInput
  }


  /**
   * product upsert
   */
  export type productUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * The filter to search for the product to update in case it exists.
     */
    where: productWhereUniqueInput
    /**
     * In case the product found by the `where` argument doesn't exist, create a new product with this data.
     */
    create: XOR<productCreateInput, productUncheckedCreateInput>
    /**
     * In case the product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productUpdateInput, productUncheckedUpdateInput>
  }


  /**
   * product delete
   */
  export type productDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
    /**
     * Filter which product to delete.
     */
    where: productWhereUniqueInput
  }


  /**
   * product deleteMany
   */
  export type productDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productWhereInput
  }


  /**
   * product.cart_product
   */
  export type product$cart_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cart_product
     */
    select?: cart_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: cart_productInclude<ExtArgs> | null
    where?: cart_productWhereInput
    orderBy?: cart_productOrderByWithRelationInput | cart_productOrderByWithRelationInput[]
    cursor?: cart_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Cart_productScalarFieldEnum | Cart_productScalarFieldEnum[]
  }


  /**
   * product.order_product
   */
  export type product$order_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order_product
     */
    select?: order_productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: order_productInclude<ExtArgs> | null
    where?: order_productWhereInput
    orderBy?: order_productOrderByWithRelationInput | order_productOrderByWithRelationInput[]
    cursor?: order_productWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Order_productScalarFieldEnum | Order_productScalarFieldEnum[]
  }


  /**
   * product without action
   */
  export type productDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the product
     */
    select?: productSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: productInclude<ExtArgs> | null
  }



  /**
   * Model session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    sid: string | null
    expire: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    sid: string | null
    expire: Date | null
  }

  export type SessionCountAggregateOutputType = {
    sid: number
    sess: number
    expire: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    sid?: true
    expire?: true
  }

  export type SessionMaxAggregateInputType = {
    sid?: true
    expire?: true
  }

  export type SessionCountAggregateInputType = {
    sid?: true
    sess?: true
    expire?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which session to aggregate.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionWhereInput
    orderBy?: sessionOrderByWithAggregationInput | sessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    sid: string
    sess: JsonValue
    expire: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sid?: boolean
    sess?: boolean
    expire?: boolean
  }, ExtArgs["result"]["session"]>

  export type sessionSelectScalar = {
    sid?: boolean
    sess?: boolean
    expire?: boolean
  }


  export type $sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "session"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      sid: string
      sess: Prisma.JsonValue
      expire: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }


  type sessionGetPayload<S extends boolean | null | undefined | sessionDefaultArgs> = $Result.GetResult<Prisma.$sessionPayload, S>

  type sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<sessionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SessionCountAggregateInputType | true
    }

  export interface sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['session'], meta: { name: 'session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {sessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends sessionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, sessionFindUniqueArgs<ExtArgs>>
    ): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {sessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends sessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends sessionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionFindFirstArgs<ExtArgs>>
    ): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends sessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `sid`
     * const sessionWithSidOnly = await prisma.session.findMany({ select: { sid: true } })
     * 
    **/
    findMany<T extends sessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Session.
     * @param {sessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
    **/
    create<T extends sessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, sessionCreateArgs<ExtArgs>>
    ): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sessions.
     *     @param {sessionCreateManyArgs} args - Arguments to create many Sessions.
     *     @example
     *     // Create many Sessions
     *     const session = await prisma.session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends sessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {sessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
    **/
    delete<T extends sessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, sessionDeleteArgs<ExtArgs>>
    ): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Session.
     * @param {sessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends sessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, sessionUpdateArgs<ExtArgs>>
    ): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {sessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends sessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, sessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends sessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, sessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {sessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
    **/
    upsert<T extends sessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, sessionUpsertArgs<ExtArgs>>
    ): Prisma__sessionClient<$Result.GetResult<Prisma.$sessionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionCountArgs>(
      args?: Subset<T, sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionGroupByArgs['orderBy'] }
        : { orderBy?: sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the session model
   */
  readonly fields: sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the session model
   */ 
  interface sessionFieldRefs {
    readonly sid: FieldRef<"session", 'String'>
    readonly sess: FieldRef<"session", 'Json'>
    readonly expire: FieldRef<"session", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * session findUnique
   */
  export type sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }


  /**
   * session findUniqueOrThrow
   */
  export type sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where: sessionWhereUniqueInput
  }


  /**
   * session findFirst
   */
  export type sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * session findFirstOrThrow
   */
  export type sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Filter, which session to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * session findMany
   */
  export type sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionOrderByWithRelationInput | sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }


  /**
   * session create
   */
  export type sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * The data needed to create a session.
     */
    data: XOR<sessionCreateInput, sessionUncheckedCreateInput>
  }


  /**
   * session createMany
   */
  export type sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionCreateManyInput | sessionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * session update
   */
  export type sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * The data needed to update a session.
     */
    data: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
    /**
     * Choose, which session to update.
     */
    where: sessionWhereUniqueInput
  }


  /**
   * session updateMany
   */
  export type sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionUpdateManyMutationInput, sessionUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionWhereInput
  }


  /**
   * session upsert
   */
  export type sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * The filter to search for the session to update in case it exists.
     */
    where: sessionWhereUniqueInput
    /**
     * In case the session found by the `where` argument doesn't exist, create a new session with this data.
     */
    create: XOR<sessionCreateInput, sessionUncheckedCreateInput>
    /**
     * In case the session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionUpdateInput, sessionUncheckedUpdateInput>
  }


  /**
   * session delete
   */
  export type sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
    /**
     * Filter which session to delete.
     */
    where: sessionWhereUniqueInput
  }


  /**
   * session deleteMany
   */
  export type sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionWhereInput
  }


  /**
   * session without action
   */
  export type sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the session
     */
    select?: sessionSelect<ExtArgs> | null
  }



  /**
   * Model address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    address: string | null
    city: string | null
    province: string | null
    country: string | null
    postal_code: string | null
    phone_number: string | null
    address_type: string | null
    user_id: number | null
    unit: string | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    first_name: string | null
    last_name: string | null
    address: string | null
    city: string | null
    province: string | null
    country: string | null
    postal_code: string | null
    phone_number: string | null
    address_type: string | null
    user_id: number | null
    unit: string | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    first_name: number
    last_name: number
    address: number
    city: number
    province: number
    country: number
    postal_code: number
    phone_number: number
    address_type: number
    user_id: number
    unit: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    address?: true
    city?: true
    province?: true
    country?: true
    postal_code?: true
    phone_number?: true
    address_type?: true
    user_id?: true
    unit?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    address?: true
    city?: true
    province?: true
    country?: true
    postal_code?: true
    phone_number?: true
    address_type?: true
    user_id?: true
    unit?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    first_name?: true
    last_name?: true
    address?: true
    city?: true
    province?: true
    country?: true
    postal_code?: true
    phone_number?: true
    address_type?: true
    user_id?: true
    unit?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which address to aggregate.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type addressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: addressWhereInput
    orderBy?: addressOrderByWithAggregationInput | addressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: addressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    user_id: number
    unit: string | null
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends addressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type addressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    country?: boolean
    postal_code?: boolean
    phone_number?: boolean
    address_type?: boolean
    user_id?: boolean
    unit?: boolean
    app_user?: boolean | app_userDefaultArgs<ExtArgs>
    checkout_session?: boolean | address$checkout_sessionArgs<ExtArgs>
    order_order_billing_address_idToaddress?: boolean | address$order_order_billing_address_idToaddressArgs<ExtArgs>
    order_order_shipping_address_idToaddress?: boolean | address$order_order_shipping_address_idToaddressArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type addressSelectScalar = {
    id?: boolean
    first_name?: boolean
    last_name?: boolean
    address?: boolean
    city?: boolean
    province?: boolean
    country?: boolean
    postal_code?: boolean
    phone_number?: boolean
    address_type?: boolean
    user_id?: boolean
    unit?: boolean
  }

  export type addressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app_user?: boolean | app_userDefaultArgs<ExtArgs>
    checkout_session?: boolean | address$checkout_sessionArgs<ExtArgs>
    order_order_billing_address_idToaddress?: boolean | address$order_order_billing_address_idToaddressArgs<ExtArgs>
    order_order_shipping_address_idToaddress?: boolean | address$order_order_shipping_address_idToaddressArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $addressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "address"
    objects: {
      app_user: Prisma.$app_userPayload<ExtArgs>
      checkout_session: Prisma.$checkout_sessionPayload<ExtArgs>[]
      order_order_billing_address_idToaddress: Prisma.$orderPayload<ExtArgs>[]
      order_order_shipping_address_idToaddress: Prisma.$orderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      first_name: string
      last_name: string
      address: string
      city: string
      province: string
      country: string
      postal_code: string
      phone_number: string
      address_type: string
      user_id: number
      unit: string | null
    }, ExtArgs["result"]["address"]>
    composites: {}
  }


  type addressGetPayload<S extends boolean | null | undefined | addressDefaultArgs> = $Result.GetResult<Prisma.$addressPayload, S>

  type addressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<addressFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AddressCountAggregateInputType | true
    }

  export interface addressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['address'], meta: { name: 'address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {addressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends addressFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, addressFindUniqueArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Address that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {addressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends addressFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends addressFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindFirstArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends addressFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends addressFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, addressFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Address.
     * @param {addressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
    **/
    create<T extends addressCreateArgs<ExtArgs>>(
      args: SelectSubset<T, addressCreateArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Addresses.
     *     @param {addressCreateManyArgs} args - Arguments to create many Addresses.
     *     @example
     *     // Create many Addresses
     *     const address = await prisma.address.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends addressCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, addressCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Address.
     * @param {addressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
    **/
    delete<T extends addressDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, addressDeleteArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Address.
     * @param {addressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends addressUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, addressUpdateArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {addressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends addressDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, addressDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends addressUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, addressUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {addressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
    **/
    upsert<T extends addressUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, addressUpsertArgs<ExtArgs>>
    ): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends addressCountArgs>(
      args?: Subset<T, addressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {addressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends addressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: addressGroupByArgs['orderBy'] }
        : { orderBy?: addressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, addressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the address model
   */
  readonly fields: addressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__addressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    app_user<T extends app_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, app_userDefaultArgs<ExtArgs>>): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    checkout_session<T extends address$checkout_sessionArgs<ExtArgs> = {}>(args?: Subset<T, address$checkout_sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'findMany'> | Null>;

    order_order_billing_address_idToaddress<T extends address$order_order_billing_address_idToaddressArgs<ExtArgs> = {}>(args?: Subset<T, address$order_order_billing_address_idToaddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'> | Null>;

    order_order_shipping_address_idToaddress<T extends address$order_order_shipping_address_idToaddressArgs<ExtArgs> = {}>(args?: Subset<T, address$order_order_shipping_address_idToaddressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the address model
   */ 
  interface addressFieldRefs {
    readonly id: FieldRef<"address", 'Int'>
    readonly first_name: FieldRef<"address", 'String'>
    readonly last_name: FieldRef<"address", 'String'>
    readonly address: FieldRef<"address", 'String'>
    readonly city: FieldRef<"address", 'String'>
    readonly province: FieldRef<"address", 'String'>
    readonly country: FieldRef<"address", 'String'>
    readonly postal_code: FieldRef<"address", 'String'>
    readonly phone_number: FieldRef<"address", 'String'>
    readonly address_type: FieldRef<"address", 'String'>
    readonly user_id: FieldRef<"address", 'Int'>
    readonly unit: FieldRef<"address", 'String'>
  }
    

  // Custom InputTypes

  /**
   * address findUnique
   */
  export type addressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where: addressWhereUniqueInput
  }


  /**
   * address findUniqueOrThrow
   */
  export type addressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where: addressWhereUniqueInput
  }


  /**
   * address findFirst
   */
  export type addressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * address findFirstOrThrow
   */
  export type addressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which address to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * address findMany
   */
  export type addressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter, which addresses to fetch.
     */
    where?: addressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of addresses to fetch.
     */
    orderBy?: addressOrderByWithRelationInput | addressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing addresses.
     */
    cursor?: addressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }


  /**
   * address create
   */
  export type addressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * The data needed to create a address.
     */
    data: XOR<addressCreateInput, addressUncheckedCreateInput>
  }


  /**
   * address createMany
   */
  export type addressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many addresses.
     */
    data: addressCreateManyInput | addressCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * address update
   */
  export type addressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * The data needed to update a address.
     */
    data: XOR<addressUpdateInput, addressUncheckedUpdateInput>
    /**
     * Choose, which address to update.
     */
    where: addressWhereUniqueInput
  }


  /**
   * address updateMany
   */
  export type addressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update addresses.
     */
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyInput>
    /**
     * Filter which addresses to update
     */
    where?: addressWhereInput
  }


  /**
   * address upsert
   */
  export type addressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * The filter to search for the address to update in case it exists.
     */
    where: addressWhereUniqueInput
    /**
     * In case the address found by the `where` argument doesn't exist, create a new address with this data.
     */
    create: XOR<addressCreateInput, addressUncheckedCreateInput>
    /**
     * In case the address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<addressUpdateInput, addressUncheckedUpdateInput>
  }


  /**
   * address delete
   */
  export type addressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    /**
     * Filter which address to delete.
     */
    where: addressWhereUniqueInput
  }


  /**
   * address deleteMany
   */
  export type addressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which addresses to delete
     */
    where?: addressWhereInput
  }


  /**
   * address.checkout_session
   */
  export type address$checkout_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    where?: checkout_sessionWhereInput
    orderBy?: checkout_sessionOrderByWithRelationInput | checkout_sessionOrderByWithRelationInput[]
    cursor?: checkout_sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Checkout_sessionScalarFieldEnum | Checkout_sessionScalarFieldEnum[]
  }


  /**
   * address.order_order_billing_address_idToaddress
   */
  export type address$order_order_billing_address_idToaddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * address.order_order_shipping_address_idToaddress
   */
  export type address$order_order_shipping_address_idToaddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * address without action
   */
  export type addressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
  }



  /**
   * Model checkout_session
   */

  export type AggregateCheckout_session = {
    _count: Checkout_sessionCountAggregateOutputType | null
    _avg: Checkout_sessionAvgAggregateOutputType | null
    _sum: Checkout_sessionSumAggregateOutputType | null
    _min: Checkout_sessionMinAggregateOutputType | null
    _max: Checkout_sessionMaxAggregateOutputType | null
  }

  export type Checkout_sessionAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    payment_card_id: number | null
    shipping_address_id: number | null
    cart_id: number | null
    billing_address_id: number | null
  }

  export type Checkout_sessionSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    payment_card_id: number | null
    shipping_address_id: number | null
    cart_id: number | null
    billing_address_id: number | null
  }

  export type Checkout_sessionMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    payment_card_id: number | null
    shipping_address_id: number | null
    cart_id: number | null
    stage: string | null
    billing_address_id: number | null
  }

  export type Checkout_sessionMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    payment_card_id: number | null
    shipping_address_id: number | null
    cart_id: number | null
    stage: string | null
    billing_address_id: number | null
  }

  export type Checkout_sessionCountAggregateOutputType = {
    id: number
    user_id: number
    payment_card_id: number
    shipping_address_id: number
    cart_id: number
    stage: number
    billing_address_id: number
    _all: number
  }


  export type Checkout_sessionAvgAggregateInputType = {
    id?: true
    user_id?: true
    payment_card_id?: true
    shipping_address_id?: true
    cart_id?: true
    billing_address_id?: true
  }

  export type Checkout_sessionSumAggregateInputType = {
    id?: true
    user_id?: true
    payment_card_id?: true
    shipping_address_id?: true
    cart_id?: true
    billing_address_id?: true
  }

  export type Checkout_sessionMinAggregateInputType = {
    id?: true
    user_id?: true
    payment_card_id?: true
    shipping_address_id?: true
    cart_id?: true
    stage?: true
    billing_address_id?: true
  }

  export type Checkout_sessionMaxAggregateInputType = {
    id?: true
    user_id?: true
    payment_card_id?: true
    shipping_address_id?: true
    cart_id?: true
    stage?: true
    billing_address_id?: true
  }

  export type Checkout_sessionCountAggregateInputType = {
    id?: true
    user_id?: true
    payment_card_id?: true
    shipping_address_id?: true
    cart_id?: true
    stage?: true
    billing_address_id?: true
    _all?: true
  }

  export type Checkout_sessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checkout_session to aggregate.
     */
    where?: checkout_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkout_sessions to fetch.
     */
    orderBy?: checkout_sessionOrderByWithRelationInput | checkout_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: checkout_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkout_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkout_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned checkout_sessions
    **/
    _count?: true | Checkout_sessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Checkout_sessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Checkout_sessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Checkout_sessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Checkout_sessionMaxAggregateInputType
  }

  export type GetCheckout_sessionAggregateType<T extends Checkout_sessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckout_session]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckout_session[P]>
      : GetScalarType<T[P], AggregateCheckout_session[P]>
  }




  export type checkout_sessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checkout_sessionWhereInput
    orderBy?: checkout_sessionOrderByWithAggregationInput | checkout_sessionOrderByWithAggregationInput[]
    by: Checkout_sessionScalarFieldEnum[] | Checkout_sessionScalarFieldEnum
    having?: checkout_sessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Checkout_sessionCountAggregateInputType | true
    _avg?: Checkout_sessionAvgAggregateInputType
    _sum?: Checkout_sessionSumAggregateInputType
    _min?: Checkout_sessionMinAggregateInputType
    _max?: Checkout_sessionMaxAggregateInputType
  }

  export type Checkout_sessionGroupByOutputType = {
    id: number
    user_id: number
    payment_card_id: number | null
    shipping_address_id: number | null
    cart_id: number
    stage: string
    billing_address_id: number | null
    _count: Checkout_sessionCountAggregateOutputType | null
    _avg: Checkout_sessionAvgAggregateOutputType | null
    _sum: Checkout_sessionSumAggregateOutputType | null
    _min: Checkout_sessionMinAggregateOutputType | null
    _max: Checkout_sessionMaxAggregateOutputType | null
  }

  type GetCheckout_sessionGroupByPayload<T extends checkout_sessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Checkout_sessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Checkout_sessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Checkout_sessionGroupByOutputType[P]>
            : GetScalarType<T[P], Checkout_sessionGroupByOutputType[P]>
        }
      >
    >


  export type checkout_sessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    payment_card_id?: boolean
    shipping_address_id?: boolean
    cart_id?: boolean
    stage?: boolean
    billing_address_id?: boolean
    cart?: boolean | cartDefaultArgs<ExtArgs>
    payment_card?: boolean | checkout_session$payment_cardArgs<ExtArgs>
    address?: boolean | checkout_session$addressArgs<ExtArgs>
    app_user?: boolean | app_userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkout_session"]>

  export type checkout_sessionSelectScalar = {
    id?: boolean
    user_id?: boolean
    payment_card_id?: boolean
    shipping_address_id?: boolean
    cart_id?: boolean
    stage?: boolean
    billing_address_id?: boolean
  }

  export type checkout_sessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cart?: boolean | cartDefaultArgs<ExtArgs>
    payment_card?: boolean | checkout_session$payment_cardArgs<ExtArgs>
    address?: boolean | checkout_session$addressArgs<ExtArgs>
    app_user?: boolean | app_userDefaultArgs<ExtArgs>
  }


  export type $checkout_sessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "checkout_session"
    objects: {
      cart: Prisma.$cartPayload<ExtArgs>
      payment_card: Prisma.$payment_cardPayload<ExtArgs> | null
      address: Prisma.$addressPayload<ExtArgs> | null
      app_user: Prisma.$app_userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      payment_card_id: number | null
      shipping_address_id: number | null
      cart_id: number
      stage: string
      billing_address_id: number | null
    }, ExtArgs["result"]["checkout_session"]>
    composites: {}
  }


  type checkout_sessionGetPayload<S extends boolean | null | undefined | checkout_sessionDefaultArgs> = $Result.GetResult<Prisma.$checkout_sessionPayload, S>

  type checkout_sessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<checkout_sessionFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Checkout_sessionCountAggregateInputType | true
    }

  export interface checkout_sessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['checkout_session'], meta: { name: 'checkout_session' } }
    /**
     * Find zero or one Checkout_session that matches the filter.
     * @param {checkout_sessionFindUniqueArgs} args - Arguments to find a Checkout_session
     * @example
     * // Get one Checkout_session
     * const checkout_session = await prisma.checkout_session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends checkout_sessionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, checkout_sessionFindUniqueArgs<ExtArgs>>
    ): Prisma__checkout_sessionClient<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Checkout_session that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {checkout_sessionFindUniqueOrThrowArgs} args - Arguments to find a Checkout_session
     * @example
     * // Get one Checkout_session
     * const checkout_session = await prisma.checkout_session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends checkout_sessionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, checkout_sessionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__checkout_sessionClient<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Checkout_session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkout_sessionFindFirstArgs} args - Arguments to find a Checkout_session
     * @example
     * // Get one Checkout_session
     * const checkout_session = await prisma.checkout_session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends checkout_sessionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, checkout_sessionFindFirstArgs<ExtArgs>>
    ): Prisma__checkout_sessionClient<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Checkout_session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkout_sessionFindFirstOrThrowArgs} args - Arguments to find a Checkout_session
     * @example
     * // Get one Checkout_session
     * const checkout_session = await prisma.checkout_session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends checkout_sessionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, checkout_sessionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__checkout_sessionClient<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Checkout_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkout_sessionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checkout_sessions
     * const checkout_sessions = await prisma.checkout_session.findMany()
     * 
     * // Get first 10 Checkout_sessions
     * const checkout_sessions = await prisma.checkout_session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkout_sessionWithIdOnly = await prisma.checkout_session.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends checkout_sessionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, checkout_sessionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Checkout_session.
     * @param {checkout_sessionCreateArgs} args - Arguments to create a Checkout_session.
     * @example
     * // Create one Checkout_session
     * const Checkout_session = await prisma.checkout_session.create({
     *   data: {
     *     // ... data to create a Checkout_session
     *   }
     * })
     * 
    **/
    create<T extends checkout_sessionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, checkout_sessionCreateArgs<ExtArgs>>
    ): Prisma__checkout_sessionClient<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Checkout_sessions.
     *     @param {checkout_sessionCreateManyArgs} args - Arguments to create many Checkout_sessions.
     *     @example
     *     // Create many Checkout_sessions
     *     const checkout_session = await prisma.checkout_session.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends checkout_sessionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, checkout_sessionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Checkout_session.
     * @param {checkout_sessionDeleteArgs} args - Arguments to delete one Checkout_session.
     * @example
     * // Delete one Checkout_session
     * const Checkout_session = await prisma.checkout_session.delete({
     *   where: {
     *     // ... filter to delete one Checkout_session
     *   }
     * })
     * 
    **/
    delete<T extends checkout_sessionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, checkout_sessionDeleteArgs<ExtArgs>>
    ): Prisma__checkout_sessionClient<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Checkout_session.
     * @param {checkout_sessionUpdateArgs} args - Arguments to update one Checkout_session.
     * @example
     * // Update one Checkout_session
     * const checkout_session = await prisma.checkout_session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends checkout_sessionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, checkout_sessionUpdateArgs<ExtArgs>>
    ): Prisma__checkout_sessionClient<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Checkout_sessions.
     * @param {checkout_sessionDeleteManyArgs} args - Arguments to filter Checkout_sessions to delete.
     * @example
     * // Delete a few Checkout_sessions
     * const { count } = await prisma.checkout_session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends checkout_sessionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, checkout_sessionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checkout_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkout_sessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checkout_sessions
     * const checkout_session = await prisma.checkout_session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends checkout_sessionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, checkout_sessionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Checkout_session.
     * @param {checkout_sessionUpsertArgs} args - Arguments to update or create a Checkout_session.
     * @example
     * // Update or create a Checkout_session
     * const checkout_session = await prisma.checkout_session.upsert({
     *   create: {
     *     // ... data to create a Checkout_session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checkout_session we want to update
     *   }
     * })
    **/
    upsert<T extends checkout_sessionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, checkout_sessionUpsertArgs<ExtArgs>>
    ): Prisma__checkout_sessionClient<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Checkout_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkout_sessionCountArgs} args - Arguments to filter Checkout_sessions to count.
     * @example
     * // Count the number of Checkout_sessions
     * const count = await prisma.checkout_session.count({
     *   where: {
     *     // ... the filter for the Checkout_sessions we want to count
     *   }
     * })
    **/
    count<T extends checkout_sessionCountArgs>(
      args?: Subset<T, checkout_sessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Checkout_sessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checkout_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Checkout_sessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Checkout_sessionAggregateArgs>(args: Subset<T, Checkout_sessionAggregateArgs>): Prisma.PrismaPromise<GetCheckout_sessionAggregateType<T>>

    /**
     * Group by Checkout_session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checkout_sessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends checkout_sessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: checkout_sessionGroupByArgs['orderBy'] }
        : { orderBy?: checkout_sessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, checkout_sessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckout_sessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the checkout_session model
   */
  readonly fields: checkout_sessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for checkout_session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__checkout_sessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cart<T extends cartDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cartDefaultArgs<ExtArgs>>): Prisma__cartClient<$Result.GetResult<Prisma.$cartPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    payment_card<T extends checkout_session$payment_cardArgs<ExtArgs> = {}>(args?: Subset<T, checkout_session$payment_cardArgs<ExtArgs>>): Prisma__payment_cardClient<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    address<T extends checkout_session$addressArgs<ExtArgs> = {}>(args?: Subset<T, checkout_session$addressArgs<ExtArgs>>): Prisma__addressClient<$Result.GetResult<Prisma.$addressPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    app_user<T extends app_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, app_userDefaultArgs<ExtArgs>>): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the checkout_session model
   */ 
  interface checkout_sessionFieldRefs {
    readonly id: FieldRef<"checkout_session", 'Int'>
    readonly user_id: FieldRef<"checkout_session", 'Int'>
    readonly payment_card_id: FieldRef<"checkout_session", 'Int'>
    readonly shipping_address_id: FieldRef<"checkout_session", 'Int'>
    readonly cart_id: FieldRef<"checkout_session", 'Int'>
    readonly stage: FieldRef<"checkout_session", 'String'>
    readonly billing_address_id: FieldRef<"checkout_session", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * checkout_session findUnique
   */
  export type checkout_sessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    /**
     * Filter, which checkout_session to fetch.
     */
    where: checkout_sessionWhereUniqueInput
  }


  /**
   * checkout_session findUniqueOrThrow
   */
  export type checkout_sessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    /**
     * Filter, which checkout_session to fetch.
     */
    where: checkout_sessionWhereUniqueInput
  }


  /**
   * checkout_session findFirst
   */
  export type checkout_sessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    /**
     * Filter, which checkout_session to fetch.
     */
    where?: checkout_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkout_sessions to fetch.
     */
    orderBy?: checkout_sessionOrderByWithRelationInput | checkout_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checkout_sessions.
     */
    cursor?: checkout_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkout_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkout_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checkout_sessions.
     */
    distinct?: Checkout_sessionScalarFieldEnum | Checkout_sessionScalarFieldEnum[]
  }


  /**
   * checkout_session findFirstOrThrow
   */
  export type checkout_sessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    /**
     * Filter, which checkout_session to fetch.
     */
    where?: checkout_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkout_sessions to fetch.
     */
    orderBy?: checkout_sessionOrderByWithRelationInput | checkout_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checkout_sessions.
     */
    cursor?: checkout_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkout_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkout_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checkout_sessions.
     */
    distinct?: Checkout_sessionScalarFieldEnum | Checkout_sessionScalarFieldEnum[]
  }


  /**
   * checkout_session findMany
   */
  export type checkout_sessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    /**
     * Filter, which checkout_sessions to fetch.
     */
    where?: checkout_sessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checkout_sessions to fetch.
     */
    orderBy?: checkout_sessionOrderByWithRelationInput | checkout_sessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing checkout_sessions.
     */
    cursor?: checkout_sessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checkout_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checkout_sessions.
     */
    skip?: number
    distinct?: Checkout_sessionScalarFieldEnum | Checkout_sessionScalarFieldEnum[]
  }


  /**
   * checkout_session create
   */
  export type checkout_sessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    /**
     * The data needed to create a checkout_session.
     */
    data: XOR<checkout_sessionCreateInput, checkout_sessionUncheckedCreateInput>
  }


  /**
   * checkout_session createMany
   */
  export type checkout_sessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many checkout_sessions.
     */
    data: checkout_sessionCreateManyInput | checkout_sessionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * checkout_session update
   */
  export type checkout_sessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    /**
     * The data needed to update a checkout_session.
     */
    data: XOR<checkout_sessionUpdateInput, checkout_sessionUncheckedUpdateInput>
    /**
     * Choose, which checkout_session to update.
     */
    where: checkout_sessionWhereUniqueInput
  }


  /**
   * checkout_session updateMany
   */
  export type checkout_sessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update checkout_sessions.
     */
    data: XOR<checkout_sessionUpdateManyMutationInput, checkout_sessionUncheckedUpdateManyInput>
    /**
     * Filter which checkout_sessions to update
     */
    where?: checkout_sessionWhereInput
  }


  /**
   * checkout_session upsert
   */
  export type checkout_sessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    /**
     * The filter to search for the checkout_session to update in case it exists.
     */
    where: checkout_sessionWhereUniqueInput
    /**
     * In case the checkout_session found by the `where` argument doesn't exist, create a new checkout_session with this data.
     */
    create: XOR<checkout_sessionCreateInput, checkout_sessionUncheckedCreateInput>
    /**
     * In case the checkout_session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<checkout_sessionUpdateInput, checkout_sessionUncheckedUpdateInput>
  }


  /**
   * checkout_session delete
   */
  export type checkout_sessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    /**
     * Filter which checkout_session to delete.
     */
    where: checkout_sessionWhereUniqueInput
  }


  /**
   * checkout_session deleteMany
   */
  export type checkout_sessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checkout_sessions to delete
     */
    where?: checkout_sessionWhereInput
  }


  /**
   * checkout_session.payment_card
   */
  export type checkout_session$payment_cardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
    where?: payment_cardWhereInput
  }


  /**
   * checkout_session.address
   */
  export type checkout_session$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the address
     */
    select?: addressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: addressInclude<ExtArgs> | null
    where?: addressWhereInput
  }


  /**
   * checkout_session without action
   */
  export type checkout_sessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
  }



  /**
   * Model payment_card
   */

  export type AggregatePayment_card = {
    _count: Payment_cardCountAggregateOutputType | null
    _avg: Payment_cardAvgAggregateOutputType | null
    _sum: Payment_cardSumAggregateOutputType | null
    _min: Payment_cardMinAggregateOutputType | null
    _max: Payment_cardMaxAggregateOutputType | null
  }

  export type Payment_cardAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Payment_cardSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type Payment_cardMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    card_number: string | null
    security_code: string | null
    expiration_month: string | null
    expiration_year: string | null
    first_name: string | null
    last_name: string | null
    payment_card_type: string | null
  }

  export type Payment_cardMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    card_number: string | null
    security_code: string | null
    expiration_month: string | null
    expiration_year: string | null
    first_name: string | null
    last_name: string | null
    payment_card_type: string | null
  }

  export type Payment_cardCountAggregateOutputType = {
    id: number
    user_id: number
    card_number: number
    security_code: number
    expiration_month: number
    expiration_year: number
    first_name: number
    last_name: number
    payment_card_type: number
    _all: number
  }


  export type Payment_cardAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Payment_cardSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type Payment_cardMinAggregateInputType = {
    id?: true
    user_id?: true
    card_number?: true
    security_code?: true
    expiration_month?: true
    expiration_year?: true
    first_name?: true
    last_name?: true
    payment_card_type?: true
  }

  export type Payment_cardMaxAggregateInputType = {
    id?: true
    user_id?: true
    card_number?: true
    security_code?: true
    expiration_month?: true
    expiration_year?: true
    first_name?: true
    last_name?: true
    payment_card_type?: true
  }

  export type Payment_cardCountAggregateInputType = {
    id?: true
    user_id?: true
    card_number?: true
    security_code?: true
    expiration_month?: true
    expiration_year?: true
    first_name?: true
    last_name?: true
    payment_card_type?: true
    _all?: true
  }

  export type Payment_cardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_card to aggregate.
     */
    where?: payment_cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_cards to fetch.
     */
    orderBy?: payment_cardOrderByWithRelationInput | payment_cardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payment_cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payment_cards
    **/
    _count?: true | Payment_cardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Payment_cardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Payment_cardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Payment_cardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Payment_cardMaxAggregateInputType
  }

  export type GetPayment_cardAggregateType<T extends Payment_cardAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment_card]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment_card[P]>
      : GetScalarType<T[P], AggregatePayment_card[P]>
  }




  export type payment_cardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payment_cardWhereInput
    orderBy?: payment_cardOrderByWithAggregationInput | payment_cardOrderByWithAggregationInput[]
    by: Payment_cardScalarFieldEnum[] | Payment_cardScalarFieldEnum
    having?: payment_cardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Payment_cardCountAggregateInputType | true
    _avg?: Payment_cardAvgAggregateInputType
    _sum?: Payment_cardSumAggregateInputType
    _min?: Payment_cardMinAggregateInputType
    _max?: Payment_cardMaxAggregateInputType
  }

  export type Payment_cardGroupByOutputType = {
    id: number
    user_id: number
    card_number: string
    security_code: string
    expiration_month: string
    expiration_year: string
    first_name: string
    last_name: string
    payment_card_type: string
    _count: Payment_cardCountAggregateOutputType | null
    _avg: Payment_cardAvgAggregateOutputType | null
    _sum: Payment_cardSumAggregateOutputType | null
    _min: Payment_cardMinAggregateOutputType | null
    _max: Payment_cardMaxAggregateOutputType | null
  }

  type GetPayment_cardGroupByPayload<T extends payment_cardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Payment_cardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Payment_cardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Payment_cardGroupByOutputType[P]>
            : GetScalarType<T[P], Payment_cardGroupByOutputType[P]>
        }
      >
    >


  export type payment_cardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    card_number?: boolean
    security_code?: boolean
    expiration_month?: boolean
    expiration_year?: boolean
    first_name?: boolean
    last_name?: boolean
    payment_card_type?: boolean
    checkout_session?: boolean | payment_card$checkout_sessionArgs<ExtArgs>
    order?: boolean | payment_card$orderArgs<ExtArgs>
    app_user?: boolean | app_userDefaultArgs<ExtArgs>
    _count?: boolean | Payment_cardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment_card"]>

  export type payment_cardSelectScalar = {
    id?: boolean
    user_id?: boolean
    card_number?: boolean
    security_code?: boolean
    expiration_month?: boolean
    expiration_year?: boolean
    first_name?: boolean
    last_name?: boolean
    payment_card_type?: boolean
  }

  export type payment_cardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkout_session?: boolean | payment_card$checkout_sessionArgs<ExtArgs>
    order?: boolean | payment_card$orderArgs<ExtArgs>
    app_user?: boolean | app_userDefaultArgs<ExtArgs>
    _count?: boolean | Payment_cardCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $payment_cardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payment_card"
    objects: {
      checkout_session: Prisma.$checkout_sessionPayload<ExtArgs>[]
      order: Prisma.$orderPayload<ExtArgs>[]
      app_user: Prisma.$app_userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      card_number: string
      security_code: string
      expiration_month: string
      expiration_year: string
      first_name: string
      last_name: string
      payment_card_type: string
    }, ExtArgs["result"]["payment_card"]>
    composites: {}
  }


  type payment_cardGetPayload<S extends boolean | null | undefined | payment_cardDefaultArgs> = $Result.GetResult<Prisma.$payment_cardPayload, S>

  type payment_cardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<payment_cardFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Payment_cardCountAggregateInputType | true
    }

  export interface payment_cardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payment_card'], meta: { name: 'payment_card' } }
    /**
     * Find zero or one Payment_card that matches the filter.
     * @param {payment_cardFindUniqueArgs} args - Arguments to find a Payment_card
     * @example
     * // Get one Payment_card
     * const payment_card = await prisma.payment_card.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends payment_cardFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, payment_cardFindUniqueArgs<ExtArgs>>
    ): Prisma__payment_cardClient<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Payment_card that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {payment_cardFindUniqueOrThrowArgs} args - Arguments to find a Payment_card
     * @example
     * // Get one Payment_card
     * const payment_card = await prisma.payment_card.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends payment_cardFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_cardFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__payment_cardClient<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Payment_card that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_cardFindFirstArgs} args - Arguments to find a Payment_card
     * @example
     * // Get one Payment_card
     * const payment_card = await prisma.payment_card.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends payment_cardFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_cardFindFirstArgs<ExtArgs>>
    ): Prisma__payment_cardClient<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Payment_card that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_cardFindFirstOrThrowArgs} args - Arguments to find a Payment_card
     * @example
     * // Get one Payment_card
     * const payment_card = await prisma.payment_card.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends payment_cardFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_cardFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__payment_cardClient<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Payment_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_cardFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payment_cards
     * const payment_cards = await prisma.payment_card.findMany()
     * 
     * // Get first 10 Payment_cards
     * const payment_cards = await prisma.payment_card.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payment_cardWithIdOnly = await prisma.payment_card.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends payment_cardFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_cardFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Payment_card.
     * @param {payment_cardCreateArgs} args - Arguments to create a Payment_card.
     * @example
     * // Create one Payment_card
     * const Payment_card = await prisma.payment_card.create({
     *   data: {
     *     // ... data to create a Payment_card
     *   }
     * })
     * 
    **/
    create<T extends payment_cardCreateArgs<ExtArgs>>(
      args: SelectSubset<T, payment_cardCreateArgs<ExtArgs>>
    ): Prisma__payment_cardClient<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Payment_cards.
     *     @param {payment_cardCreateManyArgs} args - Arguments to create many Payment_cards.
     *     @example
     *     // Create many Payment_cards
     *     const payment_card = await prisma.payment_card.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends payment_cardCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_cardCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment_card.
     * @param {payment_cardDeleteArgs} args - Arguments to delete one Payment_card.
     * @example
     * // Delete one Payment_card
     * const Payment_card = await prisma.payment_card.delete({
     *   where: {
     *     // ... filter to delete one Payment_card
     *   }
     * })
     * 
    **/
    delete<T extends payment_cardDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, payment_cardDeleteArgs<ExtArgs>>
    ): Prisma__payment_cardClient<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Payment_card.
     * @param {payment_cardUpdateArgs} args - Arguments to update one Payment_card.
     * @example
     * // Update one Payment_card
     * const payment_card = await prisma.payment_card.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends payment_cardUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, payment_cardUpdateArgs<ExtArgs>>
    ): Prisma__payment_cardClient<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Payment_cards.
     * @param {payment_cardDeleteManyArgs} args - Arguments to filter Payment_cards to delete.
     * @example
     * // Delete a few Payment_cards
     * const { count } = await prisma.payment_card.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends payment_cardDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, payment_cardDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payment_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_cardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payment_cards
     * const payment_card = await prisma.payment_card.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends payment_cardUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, payment_cardUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment_card.
     * @param {payment_cardUpsertArgs} args - Arguments to update or create a Payment_card.
     * @example
     * // Update or create a Payment_card
     * const payment_card = await prisma.payment_card.upsert({
     *   create: {
     *     // ... data to create a Payment_card
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment_card we want to update
     *   }
     * })
    **/
    upsert<T extends payment_cardUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, payment_cardUpsertArgs<ExtArgs>>
    ): Prisma__payment_cardClient<$Result.GetResult<Prisma.$payment_cardPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Payment_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_cardCountArgs} args - Arguments to filter Payment_cards to count.
     * @example
     * // Count the number of Payment_cards
     * const count = await prisma.payment_card.count({
     *   where: {
     *     // ... the filter for the Payment_cards we want to count
     *   }
     * })
    **/
    count<T extends payment_cardCountArgs>(
      args?: Subset<T, payment_cardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Payment_cardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment_card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Payment_cardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Payment_cardAggregateArgs>(args: Subset<T, Payment_cardAggregateArgs>): Prisma.PrismaPromise<GetPayment_cardAggregateType<T>>

    /**
     * Group by Payment_card.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payment_cardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payment_cardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payment_cardGroupByArgs['orderBy'] }
        : { orderBy?: payment_cardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payment_cardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayment_cardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payment_card model
   */
  readonly fields: payment_cardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payment_card.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payment_cardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    checkout_session<T extends payment_card$checkout_sessionArgs<ExtArgs> = {}>(args?: Subset<T, payment_card$checkout_sessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checkout_sessionPayload<ExtArgs>, T, 'findMany'> | Null>;

    order<T extends payment_card$orderArgs<ExtArgs> = {}>(args?: Subset<T, payment_card$orderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$orderPayload<ExtArgs>, T, 'findMany'> | Null>;

    app_user<T extends app_userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, app_userDefaultArgs<ExtArgs>>): Prisma__app_userClient<$Result.GetResult<Prisma.$app_userPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the payment_card model
   */ 
  interface payment_cardFieldRefs {
    readonly id: FieldRef<"payment_card", 'Int'>
    readonly user_id: FieldRef<"payment_card", 'Int'>
    readonly card_number: FieldRef<"payment_card", 'String'>
    readonly security_code: FieldRef<"payment_card", 'String'>
    readonly expiration_month: FieldRef<"payment_card", 'String'>
    readonly expiration_year: FieldRef<"payment_card", 'String'>
    readonly first_name: FieldRef<"payment_card", 'String'>
    readonly last_name: FieldRef<"payment_card", 'String'>
    readonly payment_card_type: FieldRef<"payment_card", 'String'>
  }
    

  // Custom InputTypes

  /**
   * payment_card findUnique
   */
  export type payment_cardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
    /**
     * Filter, which payment_card to fetch.
     */
    where: payment_cardWhereUniqueInput
  }


  /**
   * payment_card findUniqueOrThrow
   */
  export type payment_cardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
    /**
     * Filter, which payment_card to fetch.
     */
    where: payment_cardWhereUniqueInput
  }


  /**
   * payment_card findFirst
   */
  export type payment_cardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
    /**
     * Filter, which payment_card to fetch.
     */
    where?: payment_cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_cards to fetch.
     */
    orderBy?: payment_cardOrderByWithRelationInput | payment_cardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_cards.
     */
    cursor?: payment_cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_cards.
     */
    distinct?: Payment_cardScalarFieldEnum | Payment_cardScalarFieldEnum[]
  }


  /**
   * payment_card findFirstOrThrow
   */
  export type payment_cardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
    /**
     * Filter, which payment_card to fetch.
     */
    where?: payment_cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_cards to fetch.
     */
    orderBy?: payment_cardOrderByWithRelationInput | payment_cardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payment_cards.
     */
    cursor?: payment_cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payment_cards.
     */
    distinct?: Payment_cardScalarFieldEnum | Payment_cardScalarFieldEnum[]
  }


  /**
   * payment_card findMany
   */
  export type payment_cardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
    /**
     * Filter, which payment_cards to fetch.
     */
    where?: payment_cardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payment_cards to fetch.
     */
    orderBy?: payment_cardOrderByWithRelationInput | payment_cardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payment_cards.
     */
    cursor?: payment_cardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payment_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payment_cards.
     */
    skip?: number
    distinct?: Payment_cardScalarFieldEnum | Payment_cardScalarFieldEnum[]
  }


  /**
   * payment_card create
   */
  export type payment_cardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
    /**
     * The data needed to create a payment_card.
     */
    data: XOR<payment_cardCreateInput, payment_cardUncheckedCreateInput>
  }


  /**
   * payment_card createMany
   */
  export type payment_cardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payment_cards.
     */
    data: payment_cardCreateManyInput | payment_cardCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * payment_card update
   */
  export type payment_cardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
    /**
     * The data needed to update a payment_card.
     */
    data: XOR<payment_cardUpdateInput, payment_cardUncheckedUpdateInput>
    /**
     * Choose, which payment_card to update.
     */
    where: payment_cardWhereUniqueInput
  }


  /**
   * payment_card updateMany
   */
  export type payment_cardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payment_cards.
     */
    data: XOR<payment_cardUpdateManyMutationInput, payment_cardUncheckedUpdateManyInput>
    /**
     * Filter which payment_cards to update
     */
    where?: payment_cardWhereInput
  }


  /**
   * payment_card upsert
   */
  export type payment_cardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
    /**
     * The filter to search for the payment_card to update in case it exists.
     */
    where: payment_cardWhereUniqueInput
    /**
     * In case the payment_card found by the `where` argument doesn't exist, create a new payment_card with this data.
     */
    create: XOR<payment_cardCreateInput, payment_cardUncheckedCreateInput>
    /**
     * In case the payment_card was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payment_cardUpdateInput, payment_cardUncheckedUpdateInput>
  }


  /**
   * payment_card delete
   */
  export type payment_cardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
    /**
     * Filter which payment_card to delete.
     */
    where: payment_cardWhereUniqueInput
  }


  /**
   * payment_card deleteMany
   */
  export type payment_cardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payment_cards to delete
     */
    where?: payment_cardWhereInput
  }


  /**
   * payment_card.checkout_session
   */
  export type payment_card$checkout_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checkout_session
     */
    select?: checkout_sessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: checkout_sessionInclude<ExtArgs> | null
    where?: checkout_sessionWhereInput
    orderBy?: checkout_sessionOrderByWithRelationInput | checkout_sessionOrderByWithRelationInput[]
    cursor?: checkout_sessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Checkout_sessionScalarFieldEnum | Checkout_sessionScalarFieldEnum[]
  }


  /**
   * payment_card.order
   */
  export type payment_card$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the order
     */
    select?: orderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: orderInclude<ExtArgs> | null
    where?: orderWhereInput
    orderBy?: orderOrderByWithRelationInput | orderOrderByWithRelationInput[]
    cursor?: orderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }


  /**
   * payment_card without action
   */
  export type payment_cardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payment_card
     */
    select?: payment_cardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: payment_cardInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const App_userScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    password: 'password'
  };

  export type App_userScalarFieldEnum = (typeof App_userScalarFieldEnum)[keyof typeof App_userScalarFieldEnum]


  export const CartScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    num_items: 'num_items',
    total: 'total',
    subtotal: 'subtotal',
    taxes: 'taxes'
  };

  export type CartScalarFieldEnum = (typeof CartScalarFieldEnum)[keyof typeof CartScalarFieldEnum]


  export const Cart_productScalarFieldEnum: {
    product_id: 'product_id',
    cart_id: 'cart_id',
    quantity: 'quantity'
  };

  export type Cart_productScalarFieldEnum = (typeof Cart_productScalarFieldEnum)[keyof typeof Cart_productScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    order_date: 'order_date',
    total: 'total',
    subtotal: 'subtotal',
    taxes: 'taxes',
    num_items: 'num_items',
    payment_card_id: 'payment_card_id',
    shipping_address_id: 'shipping_address_id',
    billing_address_id: 'billing_address_id'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const Order_productScalarFieldEnum: {
    order_id: 'order_id',
    product_id: 'product_id',
    quantity: 'quantity'
  };

  export type Order_productScalarFieldEnum = (typeof Order_productScalarFieldEnum)[keyof typeof Order_productScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    inventory: 'inventory',
    price: 'price',
    category_code: 'category_code',
    discount_type: 'discount_type',
    total_sold: 'total_sold',
    img_filename: 'img_filename',
    discount_percent: 'discount_percent',
    item_code: 'item_code'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    sid: 'sid',
    sess: 'sess',
    expire: 'expire'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    first_name: 'first_name',
    last_name: 'last_name',
    address: 'address',
    city: 'city',
    province: 'province',
    country: 'country',
    postal_code: 'postal_code',
    phone_number: 'phone_number',
    address_type: 'address_type',
    user_id: 'user_id',
    unit: 'unit'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const Checkout_sessionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    payment_card_id: 'payment_card_id',
    shipping_address_id: 'shipping_address_id',
    cart_id: 'cart_id',
    stage: 'stage',
    billing_address_id: 'billing_address_id'
  };

  export type Checkout_sessionScalarFieldEnum = (typeof Checkout_sessionScalarFieldEnum)[keyof typeof Checkout_sessionScalarFieldEnum]


  export const Payment_cardScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    card_number: 'card_number',
    security_code: 'security_code',
    expiration_month: 'expiration_month',
    expiration_year: 'expiration_year',
    first_name: 'first_name',
    last_name: 'last_name',
    payment_card_type: 'payment_card_type'
  };

  export type Payment_cardScalarFieldEnum = (typeof Payment_cardScalarFieldEnum)[keyof typeof Payment_cardScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type app_userWhereInput = {
    AND?: app_userWhereInput | app_userWhereInput[]
    OR?: app_userWhereInput[]
    NOT?: app_userWhereInput | app_userWhereInput[]
    id?: IntFilter<"app_user"> | number
    first_name?: StringFilter<"app_user"> | string
    last_name?: StringFilter<"app_user"> | string
    email?: StringFilter<"app_user"> | string
    password?: StringFilter<"app_user"> | string
    address?: AddressListRelationFilter
    cart?: CartListRelationFilter
    checkout_session?: Checkout_sessionListRelationFilter
    order?: OrderListRelationFilter
    payment_card?: Payment_cardListRelationFilter
  }

  export type app_userOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: addressOrderByRelationAggregateInput
    cart?: cartOrderByRelationAggregateInput
    checkout_session?: checkout_sessionOrderByRelationAggregateInput
    order?: orderOrderByRelationAggregateInput
    payment_card?: payment_cardOrderByRelationAggregateInput
  }

  export type app_userWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: app_userWhereInput | app_userWhereInput[]
    OR?: app_userWhereInput[]
    NOT?: app_userWhereInput | app_userWhereInput[]
    first_name?: StringFilter<"app_user"> | string
    last_name?: StringFilter<"app_user"> | string
    password?: StringFilter<"app_user"> | string
    address?: AddressListRelationFilter
    cart?: CartListRelationFilter
    checkout_session?: Checkout_sessionListRelationFilter
    order?: OrderListRelationFilter
    payment_card?: Payment_cardListRelationFilter
  }, "id" | "email">

  export type app_userOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: app_userCountOrderByAggregateInput
    _avg?: app_userAvgOrderByAggregateInput
    _max?: app_userMaxOrderByAggregateInput
    _min?: app_userMinOrderByAggregateInput
    _sum?: app_userSumOrderByAggregateInput
  }

  export type app_userScalarWhereWithAggregatesInput = {
    AND?: app_userScalarWhereWithAggregatesInput | app_userScalarWhereWithAggregatesInput[]
    OR?: app_userScalarWhereWithAggregatesInput[]
    NOT?: app_userScalarWhereWithAggregatesInput | app_userScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"app_user"> | number
    first_name?: StringWithAggregatesFilter<"app_user"> | string
    last_name?: StringWithAggregatesFilter<"app_user"> | string
    email?: StringWithAggregatesFilter<"app_user"> | string
    password?: StringWithAggregatesFilter<"app_user"> | string
  }

  export type cartWhereInput = {
    AND?: cartWhereInput | cartWhereInput[]
    OR?: cartWhereInput[]
    NOT?: cartWhereInput | cartWhereInput[]
    id?: IntFilter<"cart"> | number
    user_id?: IntFilter<"cart"> | number
    num_items?: IntFilter<"cart"> | number
    total?: DecimalFilter<"cart"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"cart"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFilter<"cart"> | Decimal | DecimalJsLike | number | string
    app_user?: XOR<App_userRelationFilter, app_userWhereInput>
    cart_product?: Cart_productListRelationFilter
    checkout_session?: Checkout_sessionListRelationFilter
  }

  export type cartOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    num_items?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    app_user?: app_userOrderByWithRelationInput
    cart_product?: cart_productOrderByRelationAggregateInput
    checkout_session?: checkout_sessionOrderByRelationAggregateInput
  }

  export type cartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cartWhereInput | cartWhereInput[]
    OR?: cartWhereInput[]
    NOT?: cartWhereInput | cartWhereInput[]
    user_id?: IntFilter<"cart"> | number
    num_items?: IntFilter<"cart"> | number
    total?: DecimalFilter<"cart"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"cart"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFilter<"cart"> | Decimal | DecimalJsLike | number | string
    app_user?: XOR<App_userRelationFilter, app_userWhereInput>
    cart_product?: Cart_productListRelationFilter
    checkout_session?: Checkout_sessionListRelationFilter
  }, "id">

  export type cartOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    num_items?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    _count?: cartCountOrderByAggregateInput
    _avg?: cartAvgOrderByAggregateInput
    _max?: cartMaxOrderByAggregateInput
    _min?: cartMinOrderByAggregateInput
    _sum?: cartSumOrderByAggregateInput
  }

  export type cartScalarWhereWithAggregatesInput = {
    AND?: cartScalarWhereWithAggregatesInput | cartScalarWhereWithAggregatesInput[]
    OR?: cartScalarWhereWithAggregatesInput[]
    NOT?: cartScalarWhereWithAggregatesInput | cartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cart"> | number
    user_id?: IntWithAggregatesFilter<"cart"> | number
    num_items?: IntWithAggregatesFilter<"cart"> | number
    total?: DecimalWithAggregatesFilter<"cart"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalWithAggregatesFilter<"cart"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalWithAggregatesFilter<"cart"> | Decimal | DecimalJsLike | number | string
  }

  export type cart_productWhereInput = {
    AND?: cart_productWhereInput | cart_productWhereInput[]
    OR?: cart_productWhereInput[]
    NOT?: cart_productWhereInput | cart_productWhereInput[]
    product_id?: IntFilter<"cart_product"> | number
    cart_id?: IntFilter<"cart_product"> | number
    quantity?: IntFilter<"cart_product"> | number
    cart?: XOR<CartRelationFilter, cartWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type cart_productOrderByWithRelationInput = {
    product_id?: SortOrder
    cart_id?: SortOrder
    quantity?: SortOrder
    cart?: cartOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type cart_productWhereUniqueInput = Prisma.AtLeast<{
    product_id_cart_id?: cart_productProduct_idCart_idCompoundUniqueInput
    AND?: cart_productWhereInput | cart_productWhereInput[]
    OR?: cart_productWhereInput[]
    NOT?: cart_productWhereInput | cart_productWhereInput[]
    product_id?: IntFilter<"cart_product"> | number
    cart_id?: IntFilter<"cart_product"> | number
    quantity?: IntFilter<"cart_product"> | number
    cart?: XOR<CartRelationFilter, cartWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
  }, "product_id_cart_id">

  export type cart_productOrderByWithAggregationInput = {
    product_id?: SortOrder
    cart_id?: SortOrder
    quantity?: SortOrder
    _count?: cart_productCountOrderByAggregateInput
    _avg?: cart_productAvgOrderByAggregateInput
    _max?: cart_productMaxOrderByAggregateInput
    _min?: cart_productMinOrderByAggregateInput
    _sum?: cart_productSumOrderByAggregateInput
  }

  export type cart_productScalarWhereWithAggregatesInput = {
    AND?: cart_productScalarWhereWithAggregatesInput | cart_productScalarWhereWithAggregatesInput[]
    OR?: cart_productScalarWhereWithAggregatesInput[]
    NOT?: cart_productScalarWhereWithAggregatesInput | cart_productScalarWhereWithAggregatesInput[]
    product_id?: IntWithAggregatesFilter<"cart_product"> | number
    cart_id?: IntWithAggregatesFilter<"cart_product"> | number
    quantity?: IntWithAggregatesFilter<"cart_product"> | number
  }

  export type orderWhereInput = {
    AND?: orderWhereInput | orderWhereInput[]
    OR?: orderWhereInput[]
    NOT?: orderWhereInput | orderWhereInput[]
    id?: IntFilter<"order"> | number
    user_id?: IntFilter<"order"> | number
    order_date?: DateTimeFilter<"order"> | Date | string
    total?: DecimalFilter<"order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"order"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFilter<"order"> | Decimal | DecimalJsLike | number | string
    num_items?: IntFilter<"order"> | number
    payment_card_id?: IntFilter<"order"> | number
    shipping_address_id?: IntFilter<"order"> | number
    billing_address_id?: IntFilter<"order"> | number
    address_order_billing_address_idToaddress?: XOR<AddressRelationFilter, addressWhereInput>
    payment_card?: XOR<Payment_cardRelationFilter, payment_cardWhereInput>
    address_order_shipping_address_idToaddress?: XOR<AddressRelationFilter, addressWhereInput>
    app_user?: XOR<App_userRelationFilter, app_userWhereInput>
    order_product?: Order_productListRelationFilter
  }

  export type orderOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_date?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    num_items?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    billing_address_id?: SortOrder
    address_order_billing_address_idToaddress?: addressOrderByWithRelationInput
    payment_card?: payment_cardOrderByWithRelationInput
    address_order_shipping_address_idToaddress?: addressOrderByWithRelationInput
    app_user?: app_userOrderByWithRelationInput
    order_product?: order_productOrderByRelationAggregateInput
  }

  export type orderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: orderWhereInput | orderWhereInput[]
    OR?: orderWhereInput[]
    NOT?: orderWhereInput | orderWhereInput[]
    user_id?: IntFilter<"order"> | number
    order_date?: DateTimeFilter<"order"> | Date | string
    total?: DecimalFilter<"order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"order"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFilter<"order"> | Decimal | DecimalJsLike | number | string
    num_items?: IntFilter<"order"> | number
    payment_card_id?: IntFilter<"order"> | number
    shipping_address_id?: IntFilter<"order"> | number
    billing_address_id?: IntFilter<"order"> | number
    address_order_billing_address_idToaddress?: XOR<AddressRelationFilter, addressWhereInput>
    payment_card?: XOR<Payment_cardRelationFilter, payment_cardWhereInput>
    address_order_shipping_address_idToaddress?: XOR<AddressRelationFilter, addressWhereInput>
    app_user?: XOR<App_userRelationFilter, app_userWhereInput>
    order_product?: Order_productListRelationFilter
  }, "id">

  export type orderOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_date?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    num_items?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    billing_address_id?: SortOrder
    _count?: orderCountOrderByAggregateInput
    _avg?: orderAvgOrderByAggregateInput
    _max?: orderMaxOrderByAggregateInput
    _min?: orderMinOrderByAggregateInput
    _sum?: orderSumOrderByAggregateInput
  }

  export type orderScalarWhereWithAggregatesInput = {
    AND?: orderScalarWhereWithAggregatesInput | orderScalarWhereWithAggregatesInput[]
    OR?: orderScalarWhereWithAggregatesInput[]
    NOT?: orderScalarWhereWithAggregatesInput | orderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"order"> | number
    user_id?: IntWithAggregatesFilter<"order"> | number
    order_date?: DateTimeWithAggregatesFilter<"order"> | Date | string
    total?: DecimalWithAggregatesFilter<"order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalWithAggregatesFilter<"order"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalWithAggregatesFilter<"order"> | Decimal | DecimalJsLike | number | string
    num_items?: IntWithAggregatesFilter<"order"> | number
    payment_card_id?: IntWithAggregatesFilter<"order"> | number
    shipping_address_id?: IntWithAggregatesFilter<"order"> | number
    billing_address_id?: IntWithAggregatesFilter<"order"> | number
  }

  export type order_productWhereInput = {
    AND?: order_productWhereInput | order_productWhereInput[]
    OR?: order_productWhereInput[]
    NOT?: order_productWhereInput | order_productWhereInput[]
    order_id?: IntFilter<"order_product"> | number
    product_id?: IntFilter<"order_product"> | number
    quantity?: IntFilter<"order_product"> | number
    order?: XOR<OrderRelationFilter, orderWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
  }

  export type order_productOrderByWithRelationInput = {
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    order?: orderOrderByWithRelationInput
    product?: productOrderByWithRelationInput
  }

  export type order_productWhereUniqueInput = Prisma.AtLeast<{
    order_id_product_id?: order_productOrder_idProduct_idCompoundUniqueInput
    AND?: order_productWhereInput | order_productWhereInput[]
    OR?: order_productWhereInput[]
    NOT?: order_productWhereInput | order_productWhereInput[]
    order_id?: IntFilter<"order_product"> | number
    product_id?: IntFilter<"order_product"> | number
    quantity?: IntFilter<"order_product"> | number
    order?: XOR<OrderRelationFilter, orderWhereInput>
    product?: XOR<ProductRelationFilter, productWhereInput>
  }, "order_id_product_id">

  export type order_productOrderByWithAggregationInput = {
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
    _count?: order_productCountOrderByAggregateInput
    _avg?: order_productAvgOrderByAggregateInput
    _max?: order_productMaxOrderByAggregateInput
    _min?: order_productMinOrderByAggregateInput
    _sum?: order_productSumOrderByAggregateInput
  }

  export type order_productScalarWhereWithAggregatesInput = {
    AND?: order_productScalarWhereWithAggregatesInput | order_productScalarWhereWithAggregatesInput[]
    OR?: order_productScalarWhereWithAggregatesInput[]
    NOT?: order_productScalarWhereWithAggregatesInput | order_productScalarWhereWithAggregatesInput[]
    order_id?: IntWithAggregatesFilter<"order_product"> | number
    product_id?: IntWithAggregatesFilter<"order_product"> | number
    quantity?: IntWithAggregatesFilter<"order_product"> | number
  }

  export type productWhereInput = {
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    id?: IntFilter<"product"> | number
    name?: StringFilter<"product"> | string
    description?: StringFilter<"product"> | string
    inventory?: IntFilter<"product"> | number
    price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    category_code?: StringFilter<"product"> | string
    discount_type?: StringFilter<"product"> | string
    total_sold?: IntFilter<"product"> | number
    img_filename?: StringFilter<"product"> | string
    discount_percent?: IntFilter<"product"> | number
    item_code?: StringFilter<"product"> | string
    cart_product?: Cart_productListRelationFilter
    order_product?: Order_productListRelationFilter
  }

  export type productOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    inventory?: SortOrder
    price?: SortOrder
    category_code?: SortOrder
    discount_type?: SortOrder
    total_sold?: SortOrder
    img_filename?: SortOrder
    discount_percent?: SortOrder
    item_code?: SortOrder
    cart_product?: cart_productOrderByRelationAggregateInput
    order_product?: order_productOrderByRelationAggregateInput
  }

  export type productWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    item_code?: string
    AND?: productWhereInput | productWhereInput[]
    OR?: productWhereInput[]
    NOT?: productWhereInput | productWhereInput[]
    name?: StringFilter<"product"> | string
    description?: StringFilter<"product"> | string
    inventory?: IntFilter<"product"> | number
    price?: DecimalFilter<"product"> | Decimal | DecimalJsLike | number | string
    category_code?: StringFilter<"product"> | string
    discount_type?: StringFilter<"product"> | string
    total_sold?: IntFilter<"product"> | number
    img_filename?: StringFilter<"product"> | string
    discount_percent?: IntFilter<"product"> | number
    cart_product?: Cart_productListRelationFilter
    order_product?: Order_productListRelationFilter
  }, "id" | "item_code">

  export type productOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    inventory?: SortOrder
    price?: SortOrder
    category_code?: SortOrder
    discount_type?: SortOrder
    total_sold?: SortOrder
    img_filename?: SortOrder
    discount_percent?: SortOrder
    item_code?: SortOrder
    _count?: productCountOrderByAggregateInput
    _avg?: productAvgOrderByAggregateInput
    _max?: productMaxOrderByAggregateInput
    _min?: productMinOrderByAggregateInput
    _sum?: productSumOrderByAggregateInput
  }

  export type productScalarWhereWithAggregatesInput = {
    AND?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    OR?: productScalarWhereWithAggregatesInput[]
    NOT?: productScalarWhereWithAggregatesInput | productScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"product"> | number
    name?: StringWithAggregatesFilter<"product"> | string
    description?: StringWithAggregatesFilter<"product"> | string
    inventory?: IntWithAggregatesFilter<"product"> | number
    price?: DecimalWithAggregatesFilter<"product"> | Decimal | DecimalJsLike | number | string
    category_code?: StringWithAggregatesFilter<"product"> | string
    discount_type?: StringWithAggregatesFilter<"product"> | string
    total_sold?: IntWithAggregatesFilter<"product"> | number
    img_filename?: StringWithAggregatesFilter<"product"> | string
    discount_percent?: IntWithAggregatesFilter<"product"> | number
    item_code?: StringWithAggregatesFilter<"product"> | string
  }

  export type sessionWhereInput = {
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    sid?: StringFilter<"session"> | string
    sess?: JsonFilter<"session">
    expire?: DateTimeFilter<"session"> | Date | string
  }

  export type sessionOrderByWithRelationInput = {
    sid?: SortOrder
    sess?: SortOrder
    expire?: SortOrder
  }

  export type sessionWhereUniqueInput = Prisma.AtLeast<{
    sid?: string
    AND?: sessionWhereInput | sessionWhereInput[]
    OR?: sessionWhereInput[]
    NOT?: sessionWhereInput | sessionWhereInput[]
    sess?: JsonFilter<"session">
    expire?: DateTimeFilter<"session"> | Date | string
  }, "sid">

  export type sessionOrderByWithAggregationInput = {
    sid?: SortOrder
    sess?: SortOrder
    expire?: SortOrder
    _count?: sessionCountOrderByAggregateInput
    _max?: sessionMaxOrderByAggregateInput
    _min?: sessionMinOrderByAggregateInput
  }

  export type sessionScalarWhereWithAggregatesInput = {
    AND?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    OR?: sessionScalarWhereWithAggregatesInput[]
    NOT?: sessionScalarWhereWithAggregatesInput | sessionScalarWhereWithAggregatesInput[]
    sid?: StringWithAggregatesFilter<"session"> | string
    sess?: JsonWithAggregatesFilter<"session">
    expire?: DateTimeWithAggregatesFilter<"session"> | Date | string
  }

  export type addressWhereInput = {
    AND?: addressWhereInput | addressWhereInput[]
    OR?: addressWhereInput[]
    NOT?: addressWhereInput | addressWhereInput[]
    id?: IntFilter<"address"> | number
    first_name?: StringFilter<"address"> | string
    last_name?: StringFilter<"address"> | string
    address?: StringFilter<"address"> | string
    city?: StringFilter<"address"> | string
    province?: StringFilter<"address"> | string
    country?: StringFilter<"address"> | string
    postal_code?: StringFilter<"address"> | string
    phone_number?: StringFilter<"address"> | string
    address_type?: StringFilter<"address"> | string
    user_id?: IntFilter<"address"> | number
    unit?: StringNullableFilter<"address"> | string | null
    app_user?: XOR<App_userRelationFilter, app_userWhereInput>
    checkout_session?: Checkout_sessionListRelationFilter
    order_order_billing_address_idToaddress?: OrderListRelationFilter
    order_order_shipping_address_idToaddress?: OrderListRelationFilter
  }

  export type addressOrderByWithRelationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    phone_number?: SortOrder
    address_type?: SortOrder
    user_id?: SortOrder
    unit?: SortOrderInput | SortOrder
    app_user?: app_userOrderByWithRelationInput
    checkout_session?: checkout_sessionOrderByRelationAggregateInput
    order_order_billing_address_idToaddress?: orderOrderByRelationAggregateInput
    order_order_shipping_address_idToaddress?: orderOrderByRelationAggregateInput
  }

  export type addressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: addressWhereInput | addressWhereInput[]
    OR?: addressWhereInput[]
    NOT?: addressWhereInput | addressWhereInput[]
    first_name?: StringFilter<"address"> | string
    last_name?: StringFilter<"address"> | string
    address?: StringFilter<"address"> | string
    city?: StringFilter<"address"> | string
    province?: StringFilter<"address"> | string
    country?: StringFilter<"address"> | string
    postal_code?: StringFilter<"address"> | string
    phone_number?: StringFilter<"address"> | string
    address_type?: StringFilter<"address"> | string
    user_id?: IntFilter<"address"> | number
    unit?: StringNullableFilter<"address"> | string | null
    app_user?: XOR<App_userRelationFilter, app_userWhereInput>
    checkout_session?: Checkout_sessionListRelationFilter
    order_order_billing_address_idToaddress?: OrderListRelationFilter
    order_order_shipping_address_idToaddress?: OrderListRelationFilter
  }, "id">

  export type addressOrderByWithAggregationInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    phone_number?: SortOrder
    address_type?: SortOrder
    user_id?: SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: addressCountOrderByAggregateInput
    _avg?: addressAvgOrderByAggregateInput
    _max?: addressMaxOrderByAggregateInput
    _min?: addressMinOrderByAggregateInput
    _sum?: addressSumOrderByAggregateInput
  }

  export type addressScalarWhereWithAggregatesInput = {
    AND?: addressScalarWhereWithAggregatesInput | addressScalarWhereWithAggregatesInput[]
    OR?: addressScalarWhereWithAggregatesInput[]
    NOT?: addressScalarWhereWithAggregatesInput | addressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"address"> | number
    first_name?: StringWithAggregatesFilter<"address"> | string
    last_name?: StringWithAggregatesFilter<"address"> | string
    address?: StringWithAggregatesFilter<"address"> | string
    city?: StringWithAggregatesFilter<"address"> | string
    province?: StringWithAggregatesFilter<"address"> | string
    country?: StringWithAggregatesFilter<"address"> | string
    postal_code?: StringWithAggregatesFilter<"address"> | string
    phone_number?: StringWithAggregatesFilter<"address"> | string
    address_type?: StringWithAggregatesFilter<"address"> | string
    user_id?: IntWithAggregatesFilter<"address"> | number
    unit?: StringNullableWithAggregatesFilter<"address"> | string | null
  }

  export type checkout_sessionWhereInput = {
    AND?: checkout_sessionWhereInput | checkout_sessionWhereInput[]
    OR?: checkout_sessionWhereInput[]
    NOT?: checkout_sessionWhereInput | checkout_sessionWhereInput[]
    id?: IntFilter<"checkout_session"> | number
    user_id?: IntFilter<"checkout_session"> | number
    payment_card_id?: IntNullableFilter<"checkout_session"> | number | null
    shipping_address_id?: IntNullableFilter<"checkout_session"> | number | null
    cart_id?: IntFilter<"checkout_session"> | number
    stage?: StringFilter<"checkout_session"> | string
    billing_address_id?: IntNullableFilter<"checkout_session"> | number | null
    cart?: XOR<CartRelationFilter, cartWhereInput>
    payment_card?: XOR<Payment_cardNullableRelationFilter, payment_cardWhereInput> | null
    address?: XOR<AddressNullableRelationFilter, addressWhereInput> | null
    app_user?: XOR<App_userRelationFilter, app_userWhereInput>
  }

  export type checkout_sessionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_card_id?: SortOrderInput | SortOrder
    shipping_address_id?: SortOrderInput | SortOrder
    cart_id?: SortOrder
    stage?: SortOrder
    billing_address_id?: SortOrderInput | SortOrder
    cart?: cartOrderByWithRelationInput
    payment_card?: payment_cardOrderByWithRelationInput
    address?: addressOrderByWithRelationInput
    app_user?: app_userOrderByWithRelationInput
  }

  export type checkout_sessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: checkout_sessionWhereInput | checkout_sessionWhereInput[]
    OR?: checkout_sessionWhereInput[]
    NOT?: checkout_sessionWhereInput | checkout_sessionWhereInput[]
    user_id?: IntFilter<"checkout_session"> | number
    payment_card_id?: IntNullableFilter<"checkout_session"> | number | null
    shipping_address_id?: IntNullableFilter<"checkout_session"> | number | null
    cart_id?: IntFilter<"checkout_session"> | number
    stage?: StringFilter<"checkout_session"> | string
    billing_address_id?: IntNullableFilter<"checkout_session"> | number | null
    cart?: XOR<CartRelationFilter, cartWhereInput>
    payment_card?: XOR<Payment_cardNullableRelationFilter, payment_cardWhereInput> | null
    address?: XOR<AddressNullableRelationFilter, addressWhereInput> | null
    app_user?: XOR<App_userRelationFilter, app_userWhereInput>
  }, "id">

  export type checkout_sessionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_card_id?: SortOrderInput | SortOrder
    shipping_address_id?: SortOrderInput | SortOrder
    cart_id?: SortOrder
    stage?: SortOrder
    billing_address_id?: SortOrderInput | SortOrder
    _count?: checkout_sessionCountOrderByAggregateInput
    _avg?: checkout_sessionAvgOrderByAggregateInput
    _max?: checkout_sessionMaxOrderByAggregateInput
    _min?: checkout_sessionMinOrderByAggregateInput
    _sum?: checkout_sessionSumOrderByAggregateInput
  }

  export type checkout_sessionScalarWhereWithAggregatesInput = {
    AND?: checkout_sessionScalarWhereWithAggregatesInput | checkout_sessionScalarWhereWithAggregatesInput[]
    OR?: checkout_sessionScalarWhereWithAggregatesInput[]
    NOT?: checkout_sessionScalarWhereWithAggregatesInput | checkout_sessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"checkout_session"> | number
    user_id?: IntWithAggregatesFilter<"checkout_session"> | number
    payment_card_id?: IntNullableWithAggregatesFilter<"checkout_session"> | number | null
    shipping_address_id?: IntNullableWithAggregatesFilter<"checkout_session"> | number | null
    cart_id?: IntWithAggregatesFilter<"checkout_session"> | number
    stage?: StringWithAggregatesFilter<"checkout_session"> | string
    billing_address_id?: IntNullableWithAggregatesFilter<"checkout_session"> | number | null
  }

  export type payment_cardWhereInput = {
    AND?: payment_cardWhereInput | payment_cardWhereInput[]
    OR?: payment_cardWhereInput[]
    NOT?: payment_cardWhereInput | payment_cardWhereInput[]
    id?: IntFilter<"payment_card"> | number
    user_id?: IntFilter<"payment_card"> | number
    card_number?: StringFilter<"payment_card"> | string
    security_code?: StringFilter<"payment_card"> | string
    expiration_month?: StringFilter<"payment_card"> | string
    expiration_year?: StringFilter<"payment_card"> | string
    first_name?: StringFilter<"payment_card"> | string
    last_name?: StringFilter<"payment_card"> | string
    payment_card_type?: StringFilter<"payment_card"> | string
    checkout_session?: Checkout_sessionListRelationFilter
    order?: OrderListRelationFilter
    app_user?: XOR<App_userRelationFilter, app_userWhereInput>
  }

  export type payment_cardOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    card_number?: SortOrder
    security_code?: SortOrder
    expiration_month?: SortOrder
    expiration_year?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    payment_card_type?: SortOrder
    checkout_session?: checkout_sessionOrderByRelationAggregateInput
    order?: orderOrderByRelationAggregateInput
    app_user?: app_userOrderByWithRelationInput
  }

  export type payment_cardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: payment_cardWhereInput | payment_cardWhereInput[]
    OR?: payment_cardWhereInput[]
    NOT?: payment_cardWhereInput | payment_cardWhereInput[]
    user_id?: IntFilter<"payment_card"> | number
    card_number?: StringFilter<"payment_card"> | string
    security_code?: StringFilter<"payment_card"> | string
    expiration_month?: StringFilter<"payment_card"> | string
    expiration_year?: StringFilter<"payment_card"> | string
    first_name?: StringFilter<"payment_card"> | string
    last_name?: StringFilter<"payment_card"> | string
    payment_card_type?: StringFilter<"payment_card"> | string
    checkout_session?: Checkout_sessionListRelationFilter
    order?: OrderListRelationFilter
    app_user?: XOR<App_userRelationFilter, app_userWhereInput>
  }, "id">

  export type payment_cardOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    card_number?: SortOrder
    security_code?: SortOrder
    expiration_month?: SortOrder
    expiration_year?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    payment_card_type?: SortOrder
    _count?: payment_cardCountOrderByAggregateInput
    _avg?: payment_cardAvgOrderByAggregateInput
    _max?: payment_cardMaxOrderByAggregateInput
    _min?: payment_cardMinOrderByAggregateInput
    _sum?: payment_cardSumOrderByAggregateInput
  }

  export type payment_cardScalarWhereWithAggregatesInput = {
    AND?: payment_cardScalarWhereWithAggregatesInput | payment_cardScalarWhereWithAggregatesInput[]
    OR?: payment_cardScalarWhereWithAggregatesInput[]
    NOT?: payment_cardScalarWhereWithAggregatesInput | payment_cardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payment_card"> | number
    user_id?: IntWithAggregatesFilter<"payment_card"> | number
    card_number?: StringWithAggregatesFilter<"payment_card"> | string
    security_code?: StringWithAggregatesFilter<"payment_card"> | string
    expiration_month?: StringWithAggregatesFilter<"payment_card"> | string
    expiration_year?: StringWithAggregatesFilter<"payment_card"> | string
    first_name?: StringWithAggregatesFilter<"payment_card"> | string
    last_name?: StringWithAggregatesFilter<"payment_card"> | string
    payment_card_type?: StringWithAggregatesFilter<"payment_card"> | string
  }

  export type app_userCreateInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    address?: addressCreateNestedManyWithoutApp_userInput
    cart?: cartCreateNestedManyWithoutApp_userInput
    checkout_session?: checkout_sessionCreateNestedManyWithoutApp_userInput
    order?: orderCreateNestedManyWithoutApp_userInput
    payment_card?: payment_cardCreateNestedManyWithoutApp_userInput
  }

  export type app_userUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    address?: addressUncheckedCreateNestedManyWithoutApp_userInput
    cart?: cartUncheckedCreateNestedManyWithoutApp_userInput
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutApp_userInput
    order?: orderUncheckedCreateNestedManyWithoutApp_userInput
    payment_card?: payment_cardUncheckedCreateNestedManyWithoutApp_userInput
  }

  export type app_userUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: addressUpdateManyWithoutApp_userNestedInput
    cart?: cartUpdateManyWithoutApp_userNestedInput
    checkout_session?: checkout_sessionUpdateManyWithoutApp_userNestedInput
    order?: orderUpdateManyWithoutApp_userNestedInput
    payment_card?: payment_cardUpdateManyWithoutApp_userNestedInput
  }

  export type app_userUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: addressUncheckedUpdateManyWithoutApp_userNestedInput
    cart?: cartUncheckedUpdateManyWithoutApp_userNestedInput
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutApp_userNestedInput
    order?: orderUncheckedUpdateManyWithoutApp_userNestedInput
    payment_card?: payment_cardUncheckedUpdateManyWithoutApp_userNestedInput
  }

  export type app_userCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
  }

  export type app_userUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type app_userUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type cartCreateInput = {
    num_items?: number
    total?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    app_user: app_userCreateNestedOneWithoutCartInput
    cart_product?: cart_productCreateNestedManyWithoutCartInput
    checkout_session?: checkout_sessionCreateNestedManyWithoutCartInput
  }

  export type cartUncheckedCreateInput = {
    id?: number
    user_id: number
    num_items?: number
    total?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    cart_product?: cart_productUncheckedCreateNestedManyWithoutCartInput
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutCartInput
  }

  export type cartUpdateInput = {
    num_items?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    app_user?: app_userUpdateOneRequiredWithoutCartNestedInput
    cart_product?: cart_productUpdateManyWithoutCartNestedInput
    checkout_session?: checkout_sessionUpdateManyWithoutCartNestedInput
  }

  export type cartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    num_items?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cart_product?: cart_productUncheckedUpdateManyWithoutCartNestedInput
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutCartNestedInput
  }

  export type cartCreateManyInput = {
    id?: number
    user_id: number
    num_items?: number
    total?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
  }

  export type cartUpdateManyMutationInput = {
    num_items?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type cartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    num_items?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type cart_productCreateInput = {
    quantity?: number
    cart: cartCreateNestedOneWithoutCart_productInput
    product: productCreateNestedOneWithoutCart_productInput
  }

  export type cart_productUncheckedCreateInput = {
    product_id: number
    cart_id: number
    quantity?: number
  }

  export type cart_productUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    cart?: cartUpdateOneRequiredWithoutCart_productNestedInput
    product?: productUpdateOneRequiredWithoutCart_productNestedInput
  }

  export type cart_productUncheckedUpdateInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    cart_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type cart_productCreateManyInput = {
    product_id: number
    cart_id: number
    quantity?: number
  }

  export type cart_productUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type cart_productUncheckedUpdateManyInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    cart_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type orderCreateInput = {
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    address_order_billing_address_idToaddress: addressCreateNestedOneWithoutOrder_order_billing_address_idToaddressInput
    payment_card: payment_cardCreateNestedOneWithoutOrderInput
    address_order_shipping_address_idToaddress: addressCreateNestedOneWithoutOrder_order_shipping_address_idToaddressInput
    app_user: app_userCreateNestedOneWithoutOrderInput
    order_product?: order_productCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateInput = {
    id?: number
    user_id: number
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    payment_card_id: number
    shipping_address_id: number
    billing_address_id: number
    order_product?: order_productUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderUpdateInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    address_order_billing_address_idToaddress?: addressUpdateOneRequiredWithoutOrder_order_billing_address_idToaddressNestedInput
    payment_card?: payment_cardUpdateOneRequiredWithoutOrderNestedInput
    address_order_shipping_address_idToaddress?: addressUpdateOneRequiredWithoutOrder_order_shipping_address_idToaddressNestedInput
    app_user?: app_userUpdateOneRequiredWithoutOrderNestedInput
    order_product?: order_productUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    payment_card_id?: IntFieldUpdateOperationsInput | number
    shipping_address_id?: IntFieldUpdateOperationsInput | number
    billing_address_id?: IntFieldUpdateOperationsInput | number
    order_product?: order_productUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderCreateManyInput = {
    id?: number
    user_id: number
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    payment_card_id: number
    shipping_address_id: number
    billing_address_id: number
  }

  export type orderUpdateManyMutationInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
  }

  export type orderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    payment_card_id?: IntFieldUpdateOperationsInput | number
    shipping_address_id?: IntFieldUpdateOperationsInput | number
    billing_address_id?: IntFieldUpdateOperationsInput | number
  }

  export type order_productCreateInput = {
    quantity: number
    order: orderCreateNestedOneWithoutOrder_productInput
    product: productCreateNestedOneWithoutOrder_productInput
  }

  export type order_productUncheckedCreateInput = {
    order_id: number
    product_id: number
    quantity: number
  }

  export type order_productUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    order?: orderUpdateOneRequiredWithoutOrder_productNestedInput
    product?: productUpdateOneRequiredWithoutOrder_productNestedInput
  }

  export type order_productUncheckedUpdateInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type order_productCreateManyInput = {
    order_id: number
    product_id: number
    quantity: number
  }

  export type order_productUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type order_productUncheckedUpdateManyInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type productCreateInput = {
    name: string
    description: string
    inventory?: number
    price: Decimal | DecimalJsLike | number | string
    category_code: string
    discount_type?: string
    total_sold?: number
    img_filename: string
    discount_percent?: number
    item_code: string
    cart_product?: cart_productCreateNestedManyWithoutProductInput
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    inventory?: number
    price: Decimal | DecimalJsLike | number | string
    category_code: string
    discount_type?: string
    total_sold?: number
    img_filename: string
    discount_percent?: number
    item_code: string
    cart_product?: cart_productUncheckedCreateNestedManyWithoutProductInput
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category_code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    total_sold?: IntFieldUpdateOperationsInput | number
    img_filename?: StringFieldUpdateOperationsInput | string
    discount_percent?: IntFieldUpdateOperationsInput | number
    item_code?: StringFieldUpdateOperationsInput | string
    cart_product?: cart_productUpdateManyWithoutProductNestedInput
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category_code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    total_sold?: IntFieldUpdateOperationsInput | number
    img_filename?: StringFieldUpdateOperationsInput | string
    discount_percent?: IntFieldUpdateOperationsInput | number
    item_code?: StringFieldUpdateOperationsInput | string
    cart_product?: cart_productUncheckedUpdateManyWithoutProductNestedInput
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type productCreateManyInput = {
    id?: number
    name: string
    description: string
    inventory?: number
    price: Decimal | DecimalJsLike | number | string
    category_code: string
    discount_type?: string
    total_sold?: number
    img_filename: string
    discount_percent?: number
    item_code: string
  }

  export type productUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category_code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    total_sold?: IntFieldUpdateOperationsInput | number
    img_filename?: StringFieldUpdateOperationsInput | string
    discount_percent?: IntFieldUpdateOperationsInput | number
    item_code?: StringFieldUpdateOperationsInput | string
  }

  export type productUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category_code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    total_sold?: IntFieldUpdateOperationsInput | number
    img_filename?: StringFieldUpdateOperationsInput | string
    discount_percent?: IntFieldUpdateOperationsInput | number
    item_code?: StringFieldUpdateOperationsInput | string
  }

  export type sessionCreateInput = {
    sid: string
    sess: JsonNullValueInput | InputJsonValue
    expire: Date | string
  }

  export type sessionUncheckedCreateInput = {
    sid: string
    sess: JsonNullValueInput | InputJsonValue
    expire: Date | string
  }

  export type sessionUpdateInput = {
    sid?: StringFieldUpdateOperationsInput | string
    sess?: JsonNullValueInput | InputJsonValue
    expire?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionUncheckedUpdateInput = {
    sid?: StringFieldUpdateOperationsInput | string
    sess?: JsonNullValueInput | InputJsonValue
    expire?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionCreateManyInput = {
    sid: string
    sess: JsonNullValueInput | InputJsonValue
    expire: Date | string
  }

  export type sessionUpdateManyMutationInput = {
    sid?: StringFieldUpdateOperationsInput | string
    sess?: JsonNullValueInput | InputJsonValue
    expire?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionUncheckedUpdateManyInput = {
    sid?: StringFieldUpdateOperationsInput | string
    sess?: JsonNullValueInput | InputJsonValue
    expire?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type addressCreateInput = {
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    unit?: string | null
    app_user: app_userCreateNestedOneWithoutAddressInput
    checkout_session?: checkout_sessionCreateNestedManyWithoutAddressInput
    order_order_billing_address_idToaddress?: orderCreateNestedManyWithoutAddress_order_billing_address_idToaddressInput
    order_order_shipping_address_idToaddress?: orderCreateNestedManyWithoutAddress_order_shipping_address_idToaddressInput
  }

  export type addressUncheckedCreateInput = {
    id?: number
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    user_id: number
    unit?: string | null
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutAddressInput
    order_order_billing_address_idToaddress?: orderUncheckedCreateNestedManyWithoutAddress_order_billing_address_idToaddressInput
    order_order_shipping_address_idToaddress?: orderUncheckedCreateNestedManyWithoutAddress_order_shipping_address_idToaddressInput
  }

  export type addressUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    app_user?: app_userUpdateOneRequiredWithoutAddressNestedInput
    checkout_session?: checkout_sessionUpdateManyWithoutAddressNestedInput
    order_order_billing_address_idToaddress?: orderUpdateManyWithoutAddress_order_billing_address_idToaddressNestedInput
    order_order_shipping_address_idToaddress?: orderUpdateManyWithoutAddress_order_shipping_address_idToaddressNestedInput
  }

  export type addressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutAddressNestedInput
    order_order_billing_address_idToaddress?: orderUncheckedUpdateManyWithoutAddress_order_billing_address_idToaddressNestedInput
    order_order_shipping_address_idToaddress?: orderUncheckedUpdateManyWithoutAddress_order_shipping_address_idToaddressNestedInput
  }

  export type addressCreateManyInput = {
    id?: number
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    user_id: number
    unit?: string | null
  }

  export type addressUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type addressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type checkout_sessionCreateInput = {
    stage?: string
    billing_address_id?: number | null
    cart: cartCreateNestedOneWithoutCheckout_sessionInput
    payment_card?: payment_cardCreateNestedOneWithoutCheckout_sessionInput
    address?: addressCreateNestedOneWithoutCheckout_sessionInput
    app_user: app_userCreateNestedOneWithoutCheckout_sessionInput
  }

  export type checkout_sessionUncheckedCreateInput = {
    id?: number
    user_id: number
    payment_card_id?: number | null
    shipping_address_id?: number | null
    cart_id: number
    stage?: string
    billing_address_id?: number | null
  }

  export type checkout_sessionUpdateInput = {
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUpdateOneRequiredWithoutCheckout_sessionNestedInput
    payment_card?: payment_cardUpdateOneWithoutCheckout_sessionNestedInput
    address?: addressUpdateOneWithoutCheckout_sessionNestedInput
    app_user?: app_userUpdateOneRequiredWithoutCheckout_sessionNestedInput
  }

  export type checkout_sessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    payment_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart_id?: IntFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type checkout_sessionCreateManyInput = {
    id?: number
    user_id: number
    payment_card_id?: number | null
    shipping_address_id?: number | null
    cart_id: number
    stage?: string
    billing_address_id?: number | null
  }

  export type checkout_sessionUpdateManyMutationInput = {
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type checkout_sessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    payment_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart_id?: IntFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type payment_cardCreateInput = {
    card_number: string
    security_code: string
    expiration_month: string
    expiration_year: string
    first_name: string
    last_name: string
    payment_card_type: string
    checkout_session?: checkout_sessionCreateNestedManyWithoutPayment_cardInput
    order?: orderCreateNestedManyWithoutPayment_cardInput
    app_user: app_userCreateNestedOneWithoutPayment_cardInput
  }

  export type payment_cardUncheckedCreateInput = {
    id?: number
    user_id: number
    card_number: string
    security_code: string
    expiration_month: string
    expiration_year: string
    first_name: string
    last_name: string
    payment_card_type: string
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutPayment_cardInput
    order?: orderUncheckedCreateNestedManyWithoutPayment_cardInput
  }

  export type payment_cardUpdateInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    security_code?: StringFieldUpdateOperationsInput | string
    expiration_month?: StringFieldUpdateOperationsInput | string
    expiration_year?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    payment_card_type?: StringFieldUpdateOperationsInput | string
    checkout_session?: checkout_sessionUpdateManyWithoutPayment_cardNestedInput
    order?: orderUpdateManyWithoutPayment_cardNestedInput
    app_user?: app_userUpdateOneRequiredWithoutPayment_cardNestedInput
  }

  export type payment_cardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    security_code?: StringFieldUpdateOperationsInput | string
    expiration_month?: StringFieldUpdateOperationsInput | string
    expiration_year?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    payment_card_type?: StringFieldUpdateOperationsInput | string
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutPayment_cardNestedInput
    order?: orderUncheckedUpdateManyWithoutPayment_cardNestedInput
  }

  export type payment_cardCreateManyInput = {
    id?: number
    user_id: number
    card_number: string
    security_code: string
    expiration_month: string
    expiration_year: string
    first_name: string
    last_name: string
    payment_card_type: string
  }

  export type payment_cardUpdateManyMutationInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    security_code?: StringFieldUpdateOperationsInput | string
    expiration_month?: StringFieldUpdateOperationsInput | string
    expiration_year?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    payment_card_type?: StringFieldUpdateOperationsInput | string
  }

  export type payment_cardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    security_code?: StringFieldUpdateOperationsInput | string
    expiration_month?: StringFieldUpdateOperationsInput | string
    expiration_year?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    payment_card_type?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AddressListRelationFilter = {
    every?: addressWhereInput
    some?: addressWhereInput
    none?: addressWhereInput
  }

  export type CartListRelationFilter = {
    every?: cartWhereInput
    some?: cartWhereInput
    none?: cartWhereInput
  }

  export type Checkout_sessionListRelationFilter = {
    every?: checkout_sessionWhereInput
    some?: checkout_sessionWhereInput
    none?: checkout_sessionWhereInput
  }

  export type OrderListRelationFilter = {
    every?: orderWhereInput
    some?: orderWhereInput
    none?: orderWhereInput
  }

  export type Payment_cardListRelationFilter = {
    every?: payment_cardWhereInput
    some?: payment_cardWhereInput
    none?: payment_cardWhereInput
  }

  export type addressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cartOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type checkout_sessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type payment_cardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type app_userCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type app_userAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type app_userMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type app_userMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type app_userSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type App_userRelationFilter = {
    is?: app_userWhereInput
    isNot?: app_userWhereInput
  }

  export type Cart_productListRelationFilter = {
    every?: cart_productWhereInput
    some?: cart_productWhereInput
    none?: cart_productWhereInput
  }

  export type cart_productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cartCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    num_items?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
  }

  export type cartAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    num_items?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
  }

  export type cartMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    num_items?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
  }

  export type cartMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    num_items?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
  }

  export type cartSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    num_items?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type CartRelationFilter = {
    is?: cartWhereInput
    isNot?: cartWhereInput
  }

  export type ProductRelationFilter = {
    is?: productWhereInput
    isNot?: productWhereInput
  }

  export type cart_productProduct_idCart_idCompoundUniqueInput = {
    product_id: number
    cart_id: number
  }

  export type cart_productCountOrderByAggregateInput = {
    product_id?: SortOrder
    cart_id?: SortOrder
    quantity?: SortOrder
  }

  export type cart_productAvgOrderByAggregateInput = {
    product_id?: SortOrder
    cart_id?: SortOrder
    quantity?: SortOrder
  }

  export type cart_productMaxOrderByAggregateInput = {
    product_id?: SortOrder
    cart_id?: SortOrder
    quantity?: SortOrder
  }

  export type cart_productMinOrderByAggregateInput = {
    product_id?: SortOrder
    cart_id?: SortOrder
    quantity?: SortOrder
  }

  export type cart_productSumOrderByAggregateInput = {
    product_id?: SortOrder
    cart_id?: SortOrder
    quantity?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AddressRelationFilter = {
    is?: addressWhereInput
    isNot?: addressWhereInput
  }

  export type Payment_cardRelationFilter = {
    is?: payment_cardWhereInput
    isNot?: payment_cardWhereInput
  }

  export type Order_productListRelationFilter = {
    every?: order_productWhereInput
    some?: order_productWhereInput
    none?: order_productWhereInput
  }

  export type order_productOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type orderCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_date?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    num_items?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    billing_address_id?: SortOrder
  }

  export type orderAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    num_items?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    billing_address_id?: SortOrder
  }

  export type orderMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_date?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    num_items?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    billing_address_id?: SortOrder
  }

  export type orderMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    order_date?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    num_items?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    billing_address_id?: SortOrder
  }

  export type orderSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    total?: SortOrder
    subtotal?: SortOrder
    taxes?: SortOrder
    num_items?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    billing_address_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type OrderRelationFilter = {
    is?: orderWhereInput
    isNot?: orderWhereInput
  }

  export type order_productOrder_idProduct_idCompoundUniqueInput = {
    order_id: number
    product_id: number
  }

  export type order_productCountOrderByAggregateInput = {
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
  }

  export type order_productAvgOrderByAggregateInput = {
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
  }

  export type order_productMaxOrderByAggregateInput = {
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
  }

  export type order_productMinOrderByAggregateInput = {
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
  }

  export type order_productSumOrderByAggregateInput = {
    order_id?: SortOrder
    product_id?: SortOrder
    quantity?: SortOrder
  }

  export type productCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    inventory?: SortOrder
    price?: SortOrder
    category_code?: SortOrder
    discount_type?: SortOrder
    total_sold?: SortOrder
    img_filename?: SortOrder
    discount_percent?: SortOrder
    item_code?: SortOrder
  }

  export type productAvgOrderByAggregateInput = {
    id?: SortOrder
    inventory?: SortOrder
    price?: SortOrder
    total_sold?: SortOrder
    discount_percent?: SortOrder
  }

  export type productMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    inventory?: SortOrder
    price?: SortOrder
    category_code?: SortOrder
    discount_type?: SortOrder
    total_sold?: SortOrder
    img_filename?: SortOrder
    discount_percent?: SortOrder
    item_code?: SortOrder
  }

  export type productMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    inventory?: SortOrder
    price?: SortOrder
    category_code?: SortOrder
    discount_type?: SortOrder
    total_sold?: SortOrder
    img_filename?: SortOrder
    discount_percent?: SortOrder
    item_code?: SortOrder
  }

  export type productSumOrderByAggregateInput = {
    id?: SortOrder
    inventory?: SortOrder
    price?: SortOrder
    total_sold?: SortOrder
    discount_percent?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type sessionCountOrderByAggregateInput = {
    sid?: SortOrder
    sess?: SortOrder
    expire?: SortOrder
  }

  export type sessionMaxOrderByAggregateInput = {
    sid?: SortOrder
    expire?: SortOrder
  }

  export type sessionMinOrderByAggregateInput = {
    sid?: SortOrder
    expire?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type addressCountOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    phone_number?: SortOrder
    address_type?: SortOrder
    user_id?: SortOrder
    unit?: SortOrder
  }

  export type addressAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type addressMaxOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    phone_number?: SortOrder
    address_type?: SortOrder
    user_id?: SortOrder
    unit?: SortOrder
  }

  export type addressMinOrderByAggregateInput = {
    id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    address?: SortOrder
    city?: SortOrder
    province?: SortOrder
    country?: SortOrder
    postal_code?: SortOrder
    phone_number?: SortOrder
    address_type?: SortOrder
    user_id?: SortOrder
    unit?: SortOrder
  }

  export type addressSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Payment_cardNullableRelationFilter = {
    is?: payment_cardWhereInput | null
    isNot?: payment_cardWhereInput | null
  }

  export type AddressNullableRelationFilter = {
    is?: addressWhereInput | null
    isNot?: addressWhereInput | null
  }

  export type checkout_sessionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    cart_id?: SortOrder
    stage?: SortOrder
    billing_address_id?: SortOrder
  }

  export type checkout_sessionAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    cart_id?: SortOrder
    billing_address_id?: SortOrder
  }

  export type checkout_sessionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    cart_id?: SortOrder
    stage?: SortOrder
    billing_address_id?: SortOrder
  }

  export type checkout_sessionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    cart_id?: SortOrder
    stage?: SortOrder
    billing_address_id?: SortOrder
  }

  export type checkout_sessionSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    payment_card_id?: SortOrder
    shipping_address_id?: SortOrder
    cart_id?: SortOrder
    billing_address_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type payment_cardCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    card_number?: SortOrder
    security_code?: SortOrder
    expiration_month?: SortOrder
    expiration_year?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    payment_card_type?: SortOrder
  }

  export type payment_cardAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type payment_cardMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    card_number?: SortOrder
    security_code?: SortOrder
    expiration_month?: SortOrder
    expiration_year?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    payment_card_type?: SortOrder
  }

  export type payment_cardMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    card_number?: SortOrder
    security_code?: SortOrder
    expiration_month?: SortOrder
    expiration_year?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    payment_card_type?: SortOrder
  }

  export type payment_cardSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type addressCreateNestedManyWithoutApp_userInput = {
    create?: XOR<addressCreateWithoutApp_userInput, addressUncheckedCreateWithoutApp_userInput> | addressCreateWithoutApp_userInput[] | addressUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: addressCreateOrConnectWithoutApp_userInput | addressCreateOrConnectWithoutApp_userInput[]
    createMany?: addressCreateManyApp_userInputEnvelope
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
  }

  export type cartCreateNestedManyWithoutApp_userInput = {
    create?: XOR<cartCreateWithoutApp_userInput, cartUncheckedCreateWithoutApp_userInput> | cartCreateWithoutApp_userInput[] | cartUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: cartCreateOrConnectWithoutApp_userInput | cartCreateOrConnectWithoutApp_userInput[]
    createMany?: cartCreateManyApp_userInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type checkout_sessionCreateNestedManyWithoutApp_userInput = {
    create?: XOR<checkout_sessionCreateWithoutApp_userInput, checkout_sessionUncheckedCreateWithoutApp_userInput> | checkout_sessionCreateWithoutApp_userInput[] | checkout_sessionUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutApp_userInput | checkout_sessionCreateOrConnectWithoutApp_userInput[]
    createMany?: checkout_sessionCreateManyApp_userInputEnvelope
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
  }

  export type orderCreateNestedManyWithoutApp_userInput = {
    create?: XOR<orderCreateWithoutApp_userInput, orderUncheckedCreateWithoutApp_userInput> | orderCreateWithoutApp_userInput[] | orderUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: orderCreateOrConnectWithoutApp_userInput | orderCreateOrConnectWithoutApp_userInput[]
    createMany?: orderCreateManyApp_userInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type payment_cardCreateNestedManyWithoutApp_userInput = {
    create?: XOR<payment_cardCreateWithoutApp_userInput, payment_cardUncheckedCreateWithoutApp_userInput> | payment_cardCreateWithoutApp_userInput[] | payment_cardUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: payment_cardCreateOrConnectWithoutApp_userInput | payment_cardCreateOrConnectWithoutApp_userInput[]
    createMany?: payment_cardCreateManyApp_userInputEnvelope
    connect?: payment_cardWhereUniqueInput | payment_cardWhereUniqueInput[]
  }

  export type addressUncheckedCreateNestedManyWithoutApp_userInput = {
    create?: XOR<addressCreateWithoutApp_userInput, addressUncheckedCreateWithoutApp_userInput> | addressCreateWithoutApp_userInput[] | addressUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: addressCreateOrConnectWithoutApp_userInput | addressCreateOrConnectWithoutApp_userInput[]
    createMany?: addressCreateManyApp_userInputEnvelope
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
  }

  export type cartUncheckedCreateNestedManyWithoutApp_userInput = {
    create?: XOR<cartCreateWithoutApp_userInput, cartUncheckedCreateWithoutApp_userInput> | cartCreateWithoutApp_userInput[] | cartUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: cartCreateOrConnectWithoutApp_userInput | cartCreateOrConnectWithoutApp_userInput[]
    createMany?: cartCreateManyApp_userInputEnvelope
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
  }

  export type checkout_sessionUncheckedCreateNestedManyWithoutApp_userInput = {
    create?: XOR<checkout_sessionCreateWithoutApp_userInput, checkout_sessionUncheckedCreateWithoutApp_userInput> | checkout_sessionCreateWithoutApp_userInput[] | checkout_sessionUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutApp_userInput | checkout_sessionCreateOrConnectWithoutApp_userInput[]
    createMany?: checkout_sessionCreateManyApp_userInputEnvelope
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutApp_userInput = {
    create?: XOR<orderCreateWithoutApp_userInput, orderUncheckedCreateWithoutApp_userInput> | orderCreateWithoutApp_userInput[] | orderUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: orderCreateOrConnectWithoutApp_userInput | orderCreateOrConnectWithoutApp_userInput[]
    createMany?: orderCreateManyApp_userInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type payment_cardUncheckedCreateNestedManyWithoutApp_userInput = {
    create?: XOR<payment_cardCreateWithoutApp_userInput, payment_cardUncheckedCreateWithoutApp_userInput> | payment_cardCreateWithoutApp_userInput[] | payment_cardUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: payment_cardCreateOrConnectWithoutApp_userInput | payment_cardCreateOrConnectWithoutApp_userInput[]
    createMany?: payment_cardCreateManyApp_userInputEnvelope
    connect?: payment_cardWhereUniqueInput | payment_cardWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type addressUpdateManyWithoutApp_userNestedInput = {
    create?: XOR<addressCreateWithoutApp_userInput, addressUncheckedCreateWithoutApp_userInput> | addressCreateWithoutApp_userInput[] | addressUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: addressCreateOrConnectWithoutApp_userInput | addressCreateOrConnectWithoutApp_userInput[]
    upsert?: addressUpsertWithWhereUniqueWithoutApp_userInput | addressUpsertWithWhereUniqueWithoutApp_userInput[]
    createMany?: addressCreateManyApp_userInputEnvelope
    set?: addressWhereUniqueInput | addressWhereUniqueInput[]
    disconnect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    delete?: addressWhereUniqueInput | addressWhereUniqueInput[]
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    update?: addressUpdateWithWhereUniqueWithoutApp_userInput | addressUpdateWithWhereUniqueWithoutApp_userInput[]
    updateMany?: addressUpdateManyWithWhereWithoutApp_userInput | addressUpdateManyWithWhereWithoutApp_userInput[]
    deleteMany?: addressScalarWhereInput | addressScalarWhereInput[]
  }

  export type cartUpdateManyWithoutApp_userNestedInput = {
    create?: XOR<cartCreateWithoutApp_userInput, cartUncheckedCreateWithoutApp_userInput> | cartCreateWithoutApp_userInput[] | cartUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: cartCreateOrConnectWithoutApp_userInput | cartCreateOrConnectWithoutApp_userInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutApp_userInput | cartUpsertWithWhereUniqueWithoutApp_userInput[]
    createMany?: cartCreateManyApp_userInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutApp_userInput | cartUpdateWithWhereUniqueWithoutApp_userInput[]
    updateMany?: cartUpdateManyWithWhereWithoutApp_userInput | cartUpdateManyWithWhereWithoutApp_userInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type checkout_sessionUpdateManyWithoutApp_userNestedInput = {
    create?: XOR<checkout_sessionCreateWithoutApp_userInput, checkout_sessionUncheckedCreateWithoutApp_userInput> | checkout_sessionCreateWithoutApp_userInput[] | checkout_sessionUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutApp_userInput | checkout_sessionCreateOrConnectWithoutApp_userInput[]
    upsert?: checkout_sessionUpsertWithWhereUniqueWithoutApp_userInput | checkout_sessionUpsertWithWhereUniqueWithoutApp_userInput[]
    createMany?: checkout_sessionCreateManyApp_userInputEnvelope
    set?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    disconnect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    delete?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    update?: checkout_sessionUpdateWithWhereUniqueWithoutApp_userInput | checkout_sessionUpdateWithWhereUniqueWithoutApp_userInput[]
    updateMany?: checkout_sessionUpdateManyWithWhereWithoutApp_userInput | checkout_sessionUpdateManyWithWhereWithoutApp_userInput[]
    deleteMany?: checkout_sessionScalarWhereInput | checkout_sessionScalarWhereInput[]
  }

  export type orderUpdateManyWithoutApp_userNestedInput = {
    create?: XOR<orderCreateWithoutApp_userInput, orderUncheckedCreateWithoutApp_userInput> | orderCreateWithoutApp_userInput[] | orderUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: orderCreateOrConnectWithoutApp_userInput | orderCreateOrConnectWithoutApp_userInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutApp_userInput | orderUpsertWithWhereUniqueWithoutApp_userInput[]
    createMany?: orderCreateManyApp_userInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutApp_userInput | orderUpdateWithWhereUniqueWithoutApp_userInput[]
    updateMany?: orderUpdateManyWithWhereWithoutApp_userInput | orderUpdateManyWithWhereWithoutApp_userInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type payment_cardUpdateManyWithoutApp_userNestedInput = {
    create?: XOR<payment_cardCreateWithoutApp_userInput, payment_cardUncheckedCreateWithoutApp_userInput> | payment_cardCreateWithoutApp_userInput[] | payment_cardUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: payment_cardCreateOrConnectWithoutApp_userInput | payment_cardCreateOrConnectWithoutApp_userInput[]
    upsert?: payment_cardUpsertWithWhereUniqueWithoutApp_userInput | payment_cardUpsertWithWhereUniqueWithoutApp_userInput[]
    createMany?: payment_cardCreateManyApp_userInputEnvelope
    set?: payment_cardWhereUniqueInput | payment_cardWhereUniqueInput[]
    disconnect?: payment_cardWhereUniqueInput | payment_cardWhereUniqueInput[]
    delete?: payment_cardWhereUniqueInput | payment_cardWhereUniqueInput[]
    connect?: payment_cardWhereUniqueInput | payment_cardWhereUniqueInput[]
    update?: payment_cardUpdateWithWhereUniqueWithoutApp_userInput | payment_cardUpdateWithWhereUniqueWithoutApp_userInput[]
    updateMany?: payment_cardUpdateManyWithWhereWithoutApp_userInput | payment_cardUpdateManyWithWhereWithoutApp_userInput[]
    deleteMany?: payment_cardScalarWhereInput | payment_cardScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type addressUncheckedUpdateManyWithoutApp_userNestedInput = {
    create?: XOR<addressCreateWithoutApp_userInput, addressUncheckedCreateWithoutApp_userInput> | addressCreateWithoutApp_userInput[] | addressUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: addressCreateOrConnectWithoutApp_userInput | addressCreateOrConnectWithoutApp_userInput[]
    upsert?: addressUpsertWithWhereUniqueWithoutApp_userInput | addressUpsertWithWhereUniqueWithoutApp_userInput[]
    createMany?: addressCreateManyApp_userInputEnvelope
    set?: addressWhereUniqueInput | addressWhereUniqueInput[]
    disconnect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    delete?: addressWhereUniqueInput | addressWhereUniqueInput[]
    connect?: addressWhereUniqueInput | addressWhereUniqueInput[]
    update?: addressUpdateWithWhereUniqueWithoutApp_userInput | addressUpdateWithWhereUniqueWithoutApp_userInput[]
    updateMany?: addressUpdateManyWithWhereWithoutApp_userInput | addressUpdateManyWithWhereWithoutApp_userInput[]
    deleteMany?: addressScalarWhereInput | addressScalarWhereInput[]
  }

  export type cartUncheckedUpdateManyWithoutApp_userNestedInput = {
    create?: XOR<cartCreateWithoutApp_userInput, cartUncheckedCreateWithoutApp_userInput> | cartCreateWithoutApp_userInput[] | cartUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: cartCreateOrConnectWithoutApp_userInput | cartCreateOrConnectWithoutApp_userInput[]
    upsert?: cartUpsertWithWhereUniqueWithoutApp_userInput | cartUpsertWithWhereUniqueWithoutApp_userInput[]
    createMany?: cartCreateManyApp_userInputEnvelope
    set?: cartWhereUniqueInput | cartWhereUniqueInput[]
    disconnect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    delete?: cartWhereUniqueInput | cartWhereUniqueInput[]
    connect?: cartWhereUniqueInput | cartWhereUniqueInput[]
    update?: cartUpdateWithWhereUniqueWithoutApp_userInput | cartUpdateWithWhereUniqueWithoutApp_userInput[]
    updateMany?: cartUpdateManyWithWhereWithoutApp_userInput | cartUpdateManyWithWhereWithoutApp_userInput[]
    deleteMany?: cartScalarWhereInput | cartScalarWhereInput[]
  }

  export type checkout_sessionUncheckedUpdateManyWithoutApp_userNestedInput = {
    create?: XOR<checkout_sessionCreateWithoutApp_userInput, checkout_sessionUncheckedCreateWithoutApp_userInput> | checkout_sessionCreateWithoutApp_userInput[] | checkout_sessionUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutApp_userInput | checkout_sessionCreateOrConnectWithoutApp_userInput[]
    upsert?: checkout_sessionUpsertWithWhereUniqueWithoutApp_userInput | checkout_sessionUpsertWithWhereUniqueWithoutApp_userInput[]
    createMany?: checkout_sessionCreateManyApp_userInputEnvelope
    set?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    disconnect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    delete?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    update?: checkout_sessionUpdateWithWhereUniqueWithoutApp_userInput | checkout_sessionUpdateWithWhereUniqueWithoutApp_userInput[]
    updateMany?: checkout_sessionUpdateManyWithWhereWithoutApp_userInput | checkout_sessionUpdateManyWithWhereWithoutApp_userInput[]
    deleteMany?: checkout_sessionScalarWhereInput | checkout_sessionScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutApp_userNestedInput = {
    create?: XOR<orderCreateWithoutApp_userInput, orderUncheckedCreateWithoutApp_userInput> | orderCreateWithoutApp_userInput[] | orderUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: orderCreateOrConnectWithoutApp_userInput | orderCreateOrConnectWithoutApp_userInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutApp_userInput | orderUpsertWithWhereUniqueWithoutApp_userInput[]
    createMany?: orderCreateManyApp_userInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutApp_userInput | orderUpdateWithWhereUniqueWithoutApp_userInput[]
    updateMany?: orderUpdateManyWithWhereWithoutApp_userInput | orderUpdateManyWithWhereWithoutApp_userInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type payment_cardUncheckedUpdateManyWithoutApp_userNestedInput = {
    create?: XOR<payment_cardCreateWithoutApp_userInput, payment_cardUncheckedCreateWithoutApp_userInput> | payment_cardCreateWithoutApp_userInput[] | payment_cardUncheckedCreateWithoutApp_userInput[]
    connectOrCreate?: payment_cardCreateOrConnectWithoutApp_userInput | payment_cardCreateOrConnectWithoutApp_userInput[]
    upsert?: payment_cardUpsertWithWhereUniqueWithoutApp_userInput | payment_cardUpsertWithWhereUniqueWithoutApp_userInput[]
    createMany?: payment_cardCreateManyApp_userInputEnvelope
    set?: payment_cardWhereUniqueInput | payment_cardWhereUniqueInput[]
    disconnect?: payment_cardWhereUniqueInput | payment_cardWhereUniqueInput[]
    delete?: payment_cardWhereUniqueInput | payment_cardWhereUniqueInput[]
    connect?: payment_cardWhereUniqueInput | payment_cardWhereUniqueInput[]
    update?: payment_cardUpdateWithWhereUniqueWithoutApp_userInput | payment_cardUpdateWithWhereUniqueWithoutApp_userInput[]
    updateMany?: payment_cardUpdateManyWithWhereWithoutApp_userInput | payment_cardUpdateManyWithWhereWithoutApp_userInput[]
    deleteMany?: payment_cardScalarWhereInput | payment_cardScalarWhereInput[]
  }

  export type app_userCreateNestedOneWithoutCartInput = {
    create?: XOR<app_userCreateWithoutCartInput, app_userUncheckedCreateWithoutCartInput>
    connectOrCreate?: app_userCreateOrConnectWithoutCartInput
    connect?: app_userWhereUniqueInput
  }

  export type cart_productCreateNestedManyWithoutCartInput = {
    create?: XOR<cart_productCreateWithoutCartInput, cart_productUncheckedCreateWithoutCartInput> | cart_productCreateWithoutCartInput[] | cart_productUncheckedCreateWithoutCartInput[]
    connectOrCreate?: cart_productCreateOrConnectWithoutCartInput | cart_productCreateOrConnectWithoutCartInput[]
    createMany?: cart_productCreateManyCartInputEnvelope
    connect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
  }

  export type checkout_sessionCreateNestedManyWithoutCartInput = {
    create?: XOR<checkout_sessionCreateWithoutCartInput, checkout_sessionUncheckedCreateWithoutCartInput> | checkout_sessionCreateWithoutCartInput[] | checkout_sessionUncheckedCreateWithoutCartInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutCartInput | checkout_sessionCreateOrConnectWithoutCartInput[]
    createMany?: checkout_sessionCreateManyCartInputEnvelope
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
  }

  export type cart_productUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<cart_productCreateWithoutCartInput, cart_productUncheckedCreateWithoutCartInput> | cart_productCreateWithoutCartInput[] | cart_productUncheckedCreateWithoutCartInput[]
    connectOrCreate?: cart_productCreateOrConnectWithoutCartInput | cart_productCreateOrConnectWithoutCartInput[]
    createMany?: cart_productCreateManyCartInputEnvelope
    connect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
  }

  export type checkout_sessionUncheckedCreateNestedManyWithoutCartInput = {
    create?: XOR<checkout_sessionCreateWithoutCartInput, checkout_sessionUncheckedCreateWithoutCartInput> | checkout_sessionCreateWithoutCartInput[] | checkout_sessionUncheckedCreateWithoutCartInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutCartInput | checkout_sessionCreateOrConnectWithoutCartInput[]
    createMany?: checkout_sessionCreateManyCartInputEnvelope
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type app_userUpdateOneRequiredWithoutCartNestedInput = {
    create?: XOR<app_userCreateWithoutCartInput, app_userUncheckedCreateWithoutCartInput>
    connectOrCreate?: app_userCreateOrConnectWithoutCartInput
    upsert?: app_userUpsertWithoutCartInput
    connect?: app_userWhereUniqueInput
    update?: XOR<XOR<app_userUpdateToOneWithWhereWithoutCartInput, app_userUpdateWithoutCartInput>, app_userUncheckedUpdateWithoutCartInput>
  }

  export type cart_productUpdateManyWithoutCartNestedInput = {
    create?: XOR<cart_productCreateWithoutCartInput, cart_productUncheckedCreateWithoutCartInput> | cart_productCreateWithoutCartInput[] | cart_productUncheckedCreateWithoutCartInput[]
    connectOrCreate?: cart_productCreateOrConnectWithoutCartInput | cart_productCreateOrConnectWithoutCartInput[]
    upsert?: cart_productUpsertWithWhereUniqueWithoutCartInput | cart_productUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: cart_productCreateManyCartInputEnvelope
    set?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    disconnect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    delete?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    connect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    update?: cart_productUpdateWithWhereUniqueWithoutCartInput | cart_productUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: cart_productUpdateManyWithWhereWithoutCartInput | cart_productUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: cart_productScalarWhereInput | cart_productScalarWhereInput[]
  }

  export type checkout_sessionUpdateManyWithoutCartNestedInput = {
    create?: XOR<checkout_sessionCreateWithoutCartInput, checkout_sessionUncheckedCreateWithoutCartInput> | checkout_sessionCreateWithoutCartInput[] | checkout_sessionUncheckedCreateWithoutCartInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutCartInput | checkout_sessionCreateOrConnectWithoutCartInput[]
    upsert?: checkout_sessionUpsertWithWhereUniqueWithoutCartInput | checkout_sessionUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: checkout_sessionCreateManyCartInputEnvelope
    set?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    disconnect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    delete?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    update?: checkout_sessionUpdateWithWhereUniqueWithoutCartInput | checkout_sessionUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: checkout_sessionUpdateManyWithWhereWithoutCartInput | checkout_sessionUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: checkout_sessionScalarWhereInput | checkout_sessionScalarWhereInput[]
  }

  export type cart_productUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<cart_productCreateWithoutCartInput, cart_productUncheckedCreateWithoutCartInput> | cart_productCreateWithoutCartInput[] | cart_productUncheckedCreateWithoutCartInput[]
    connectOrCreate?: cart_productCreateOrConnectWithoutCartInput | cart_productCreateOrConnectWithoutCartInput[]
    upsert?: cart_productUpsertWithWhereUniqueWithoutCartInput | cart_productUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: cart_productCreateManyCartInputEnvelope
    set?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    disconnect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    delete?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    connect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    update?: cart_productUpdateWithWhereUniqueWithoutCartInput | cart_productUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: cart_productUpdateManyWithWhereWithoutCartInput | cart_productUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: cart_productScalarWhereInput | cart_productScalarWhereInput[]
  }

  export type checkout_sessionUncheckedUpdateManyWithoutCartNestedInput = {
    create?: XOR<checkout_sessionCreateWithoutCartInput, checkout_sessionUncheckedCreateWithoutCartInput> | checkout_sessionCreateWithoutCartInput[] | checkout_sessionUncheckedCreateWithoutCartInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutCartInput | checkout_sessionCreateOrConnectWithoutCartInput[]
    upsert?: checkout_sessionUpsertWithWhereUniqueWithoutCartInput | checkout_sessionUpsertWithWhereUniqueWithoutCartInput[]
    createMany?: checkout_sessionCreateManyCartInputEnvelope
    set?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    disconnect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    delete?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    update?: checkout_sessionUpdateWithWhereUniqueWithoutCartInput | checkout_sessionUpdateWithWhereUniqueWithoutCartInput[]
    updateMany?: checkout_sessionUpdateManyWithWhereWithoutCartInput | checkout_sessionUpdateManyWithWhereWithoutCartInput[]
    deleteMany?: checkout_sessionScalarWhereInput | checkout_sessionScalarWhereInput[]
  }

  export type cartCreateNestedOneWithoutCart_productInput = {
    create?: XOR<cartCreateWithoutCart_productInput, cartUncheckedCreateWithoutCart_productInput>
    connectOrCreate?: cartCreateOrConnectWithoutCart_productInput
    connect?: cartWhereUniqueInput
  }

  export type productCreateNestedOneWithoutCart_productInput = {
    create?: XOR<productCreateWithoutCart_productInput, productUncheckedCreateWithoutCart_productInput>
    connectOrCreate?: productCreateOrConnectWithoutCart_productInput
    connect?: productWhereUniqueInput
  }

  export type cartUpdateOneRequiredWithoutCart_productNestedInput = {
    create?: XOR<cartCreateWithoutCart_productInput, cartUncheckedCreateWithoutCart_productInput>
    connectOrCreate?: cartCreateOrConnectWithoutCart_productInput
    upsert?: cartUpsertWithoutCart_productInput
    connect?: cartWhereUniqueInput
    update?: XOR<XOR<cartUpdateToOneWithWhereWithoutCart_productInput, cartUpdateWithoutCart_productInput>, cartUncheckedUpdateWithoutCart_productInput>
  }

  export type productUpdateOneRequiredWithoutCart_productNestedInput = {
    create?: XOR<productCreateWithoutCart_productInput, productUncheckedCreateWithoutCart_productInput>
    connectOrCreate?: productCreateOrConnectWithoutCart_productInput
    upsert?: productUpsertWithoutCart_productInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutCart_productInput, productUpdateWithoutCart_productInput>, productUncheckedUpdateWithoutCart_productInput>
  }

  export type addressCreateNestedOneWithoutOrder_order_billing_address_idToaddressInput = {
    create?: XOR<addressCreateWithoutOrder_order_billing_address_idToaddressInput, addressUncheckedCreateWithoutOrder_order_billing_address_idToaddressInput>
    connectOrCreate?: addressCreateOrConnectWithoutOrder_order_billing_address_idToaddressInput
    connect?: addressWhereUniqueInput
  }

  export type payment_cardCreateNestedOneWithoutOrderInput = {
    create?: XOR<payment_cardCreateWithoutOrderInput, payment_cardUncheckedCreateWithoutOrderInput>
    connectOrCreate?: payment_cardCreateOrConnectWithoutOrderInput
    connect?: payment_cardWhereUniqueInput
  }

  export type addressCreateNestedOneWithoutOrder_order_shipping_address_idToaddressInput = {
    create?: XOR<addressCreateWithoutOrder_order_shipping_address_idToaddressInput, addressUncheckedCreateWithoutOrder_order_shipping_address_idToaddressInput>
    connectOrCreate?: addressCreateOrConnectWithoutOrder_order_shipping_address_idToaddressInput
    connect?: addressWhereUniqueInput
  }

  export type app_userCreateNestedOneWithoutOrderInput = {
    create?: XOR<app_userCreateWithoutOrderInput, app_userUncheckedCreateWithoutOrderInput>
    connectOrCreate?: app_userCreateOrConnectWithoutOrderInput
    connect?: app_userWhereUniqueInput
  }

  export type order_productCreateNestedManyWithoutOrderInput = {
    create?: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput> | order_productCreateWithoutOrderInput[] | order_productUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutOrderInput | order_productCreateOrConnectWithoutOrderInput[]
    createMany?: order_productCreateManyOrderInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type order_productUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput> | order_productCreateWithoutOrderInput[] | order_productUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutOrderInput | order_productCreateOrConnectWithoutOrderInput[]
    createMany?: order_productCreateManyOrderInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type addressUpdateOneRequiredWithoutOrder_order_billing_address_idToaddressNestedInput = {
    create?: XOR<addressCreateWithoutOrder_order_billing_address_idToaddressInput, addressUncheckedCreateWithoutOrder_order_billing_address_idToaddressInput>
    connectOrCreate?: addressCreateOrConnectWithoutOrder_order_billing_address_idToaddressInput
    upsert?: addressUpsertWithoutOrder_order_billing_address_idToaddressInput
    connect?: addressWhereUniqueInput
    update?: XOR<XOR<addressUpdateToOneWithWhereWithoutOrder_order_billing_address_idToaddressInput, addressUpdateWithoutOrder_order_billing_address_idToaddressInput>, addressUncheckedUpdateWithoutOrder_order_billing_address_idToaddressInput>
  }

  export type payment_cardUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<payment_cardCreateWithoutOrderInput, payment_cardUncheckedCreateWithoutOrderInput>
    connectOrCreate?: payment_cardCreateOrConnectWithoutOrderInput
    upsert?: payment_cardUpsertWithoutOrderInput
    connect?: payment_cardWhereUniqueInput
    update?: XOR<XOR<payment_cardUpdateToOneWithWhereWithoutOrderInput, payment_cardUpdateWithoutOrderInput>, payment_cardUncheckedUpdateWithoutOrderInput>
  }

  export type addressUpdateOneRequiredWithoutOrder_order_shipping_address_idToaddressNestedInput = {
    create?: XOR<addressCreateWithoutOrder_order_shipping_address_idToaddressInput, addressUncheckedCreateWithoutOrder_order_shipping_address_idToaddressInput>
    connectOrCreate?: addressCreateOrConnectWithoutOrder_order_shipping_address_idToaddressInput
    upsert?: addressUpsertWithoutOrder_order_shipping_address_idToaddressInput
    connect?: addressWhereUniqueInput
    update?: XOR<XOR<addressUpdateToOneWithWhereWithoutOrder_order_shipping_address_idToaddressInput, addressUpdateWithoutOrder_order_shipping_address_idToaddressInput>, addressUncheckedUpdateWithoutOrder_order_shipping_address_idToaddressInput>
  }

  export type app_userUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<app_userCreateWithoutOrderInput, app_userUncheckedCreateWithoutOrderInput>
    connectOrCreate?: app_userCreateOrConnectWithoutOrderInput
    upsert?: app_userUpsertWithoutOrderInput
    connect?: app_userWhereUniqueInput
    update?: XOR<XOR<app_userUpdateToOneWithWhereWithoutOrderInput, app_userUpdateWithoutOrderInput>, app_userUncheckedUpdateWithoutOrderInput>
  }

  export type order_productUpdateManyWithoutOrderNestedInput = {
    create?: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput> | order_productCreateWithoutOrderInput[] | order_productUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutOrderInput | order_productCreateOrConnectWithoutOrderInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutOrderInput | order_productUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: order_productCreateManyOrderInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutOrderInput | order_productUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutOrderInput | order_productUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type order_productUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput> | order_productCreateWithoutOrderInput[] | order_productUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutOrderInput | order_productCreateOrConnectWithoutOrderInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutOrderInput | order_productUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: order_productCreateManyOrderInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutOrderInput | order_productUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutOrderInput | order_productUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type orderCreateNestedOneWithoutOrder_productInput = {
    create?: XOR<orderCreateWithoutOrder_productInput, orderUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: orderCreateOrConnectWithoutOrder_productInput
    connect?: orderWhereUniqueInput
  }

  export type productCreateNestedOneWithoutOrder_productInput = {
    create?: XOR<productCreateWithoutOrder_productInput, productUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: productCreateOrConnectWithoutOrder_productInput
    connect?: productWhereUniqueInput
  }

  export type orderUpdateOneRequiredWithoutOrder_productNestedInput = {
    create?: XOR<orderCreateWithoutOrder_productInput, orderUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: orderCreateOrConnectWithoutOrder_productInput
    upsert?: orderUpsertWithoutOrder_productInput
    connect?: orderWhereUniqueInput
    update?: XOR<XOR<orderUpdateToOneWithWhereWithoutOrder_productInput, orderUpdateWithoutOrder_productInput>, orderUncheckedUpdateWithoutOrder_productInput>
  }

  export type productUpdateOneRequiredWithoutOrder_productNestedInput = {
    create?: XOR<productCreateWithoutOrder_productInput, productUncheckedCreateWithoutOrder_productInput>
    connectOrCreate?: productCreateOrConnectWithoutOrder_productInput
    upsert?: productUpsertWithoutOrder_productInput
    connect?: productWhereUniqueInput
    update?: XOR<XOR<productUpdateToOneWithWhereWithoutOrder_productInput, productUpdateWithoutOrder_productInput>, productUncheckedUpdateWithoutOrder_productInput>
  }

  export type cart_productCreateNestedManyWithoutProductInput = {
    create?: XOR<cart_productCreateWithoutProductInput, cart_productUncheckedCreateWithoutProductInput> | cart_productCreateWithoutProductInput[] | cart_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cart_productCreateOrConnectWithoutProductInput | cart_productCreateOrConnectWithoutProductInput[]
    createMany?: cart_productCreateManyProductInputEnvelope
    connect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
  }

  export type order_productCreateNestedManyWithoutProductInput = {
    create?: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput> | order_productCreateWithoutProductInput[] | order_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProductInput | order_productCreateOrConnectWithoutProductInput[]
    createMany?: order_productCreateManyProductInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type cart_productUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<cart_productCreateWithoutProductInput, cart_productUncheckedCreateWithoutProductInput> | cart_productCreateWithoutProductInput[] | cart_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cart_productCreateOrConnectWithoutProductInput | cart_productCreateOrConnectWithoutProductInput[]
    createMany?: cart_productCreateManyProductInputEnvelope
    connect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
  }

  export type order_productUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput> | order_productCreateWithoutProductInput[] | order_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProductInput | order_productCreateOrConnectWithoutProductInput[]
    createMany?: order_productCreateManyProductInputEnvelope
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
  }

  export type cart_productUpdateManyWithoutProductNestedInput = {
    create?: XOR<cart_productCreateWithoutProductInput, cart_productUncheckedCreateWithoutProductInput> | cart_productCreateWithoutProductInput[] | cart_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cart_productCreateOrConnectWithoutProductInput | cart_productCreateOrConnectWithoutProductInput[]
    upsert?: cart_productUpsertWithWhereUniqueWithoutProductInput | cart_productUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: cart_productCreateManyProductInputEnvelope
    set?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    disconnect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    delete?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    connect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    update?: cart_productUpdateWithWhereUniqueWithoutProductInput | cart_productUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: cart_productUpdateManyWithWhereWithoutProductInput | cart_productUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: cart_productScalarWhereInput | cart_productScalarWhereInput[]
  }

  export type order_productUpdateManyWithoutProductNestedInput = {
    create?: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput> | order_productCreateWithoutProductInput[] | order_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProductInput | order_productCreateOrConnectWithoutProductInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutProductInput | order_productUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: order_productCreateManyProductInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutProductInput | order_productUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutProductInput | order_productUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type cart_productUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<cart_productCreateWithoutProductInput, cart_productUncheckedCreateWithoutProductInput> | cart_productCreateWithoutProductInput[] | cart_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: cart_productCreateOrConnectWithoutProductInput | cart_productCreateOrConnectWithoutProductInput[]
    upsert?: cart_productUpsertWithWhereUniqueWithoutProductInput | cart_productUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: cart_productCreateManyProductInputEnvelope
    set?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    disconnect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    delete?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    connect?: cart_productWhereUniqueInput | cart_productWhereUniqueInput[]
    update?: cart_productUpdateWithWhereUniqueWithoutProductInput | cart_productUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: cart_productUpdateManyWithWhereWithoutProductInput | cart_productUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: cart_productScalarWhereInput | cart_productScalarWhereInput[]
  }

  export type order_productUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput> | order_productCreateWithoutProductInput[] | order_productUncheckedCreateWithoutProductInput[]
    connectOrCreate?: order_productCreateOrConnectWithoutProductInput | order_productCreateOrConnectWithoutProductInput[]
    upsert?: order_productUpsertWithWhereUniqueWithoutProductInput | order_productUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: order_productCreateManyProductInputEnvelope
    set?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    disconnect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    delete?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    connect?: order_productWhereUniqueInput | order_productWhereUniqueInput[]
    update?: order_productUpdateWithWhereUniqueWithoutProductInput | order_productUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: order_productUpdateManyWithWhereWithoutProductInput | order_productUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: order_productScalarWhereInput | order_productScalarWhereInput[]
  }

  export type app_userCreateNestedOneWithoutAddressInput = {
    create?: XOR<app_userCreateWithoutAddressInput, app_userUncheckedCreateWithoutAddressInput>
    connectOrCreate?: app_userCreateOrConnectWithoutAddressInput
    connect?: app_userWhereUniqueInput
  }

  export type checkout_sessionCreateNestedManyWithoutAddressInput = {
    create?: XOR<checkout_sessionCreateWithoutAddressInput, checkout_sessionUncheckedCreateWithoutAddressInput> | checkout_sessionCreateWithoutAddressInput[] | checkout_sessionUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutAddressInput | checkout_sessionCreateOrConnectWithoutAddressInput[]
    createMany?: checkout_sessionCreateManyAddressInputEnvelope
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
  }

  export type orderCreateNestedManyWithoutAddress_order_billing_address_idToaddressInput = {
    create?: XOR<orderCreateWithoutAddress_order_billing_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_billing_address_idToaddressInput> | orderCreateWithoutAddress_order_billing_address_idToaddressInput[] | orderUncheckedCreateWithoutAddress_order_billing_address_idToaddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddress_order_billing_address_idToaddressInput | orderCreateOrConnectWithoutAddress_order_billing_address_idToaddressInput[]
    createMany?: orderCreateManyAddress_order_billing_address_idToaddressInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type orderCreateNestedManyWithoutAddress_order_shipping_address_idToaddressInput = {
    create?: XOR<orderCreateWithoutAddress_order_shipping_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_shipping_address_idToaddressInput> | orderCreateWithoutAddress_order_shipping_address_idToaddressInput[] | orderUncheckedCreateWithoutAddress_order_shipping_address_idToaddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddress_order_shipping_address_idToaddressInput | orderCreateOrConnectWithoutAddress_order_shipping_address_idToaddressInput[]
    createMany?: orderCreateManyAddress_order_shipping_address_idToaddressInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type checkout_sessionUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<checkout_sessionCreateWithoutAddressInput, checkout_sessionUncheckedCreateWithoutAddressInput> | checkout_sessionCreateWithoutAddressInput[] | checkout_sessionUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutAddressInput | checkout_sessionCreateOrConnectWithoutAddressInput[]
    createMany?: checkout_sessionCreateManyAddressInputEnvelope
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutAddress_order_billing_address_idToaddressInput = {
    create?: XOR<orderCreateWithoutAddress_order_billing_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_billing_address_idToaddressInput> | orderCreateWithoutAddress_order_billing_address_idToaddressInput[] | orderUncheckedCreateWithoutAddress_order_billing_address_idToaddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddress_order_billing_address_idToaddressInput | orderCreateOrConnectWithoutAddress_order_billing_address_idToaddressInput[]
    createMany?: orderCreateManyAddress_order_billing_address_idToaddressInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutAddress_order_shipping_address_idToaddressInput = {
    create?: XOR<orderCreateWithoutAddress_order_shipping_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_shipping_address_idToaddressInput> | orderCreateWithoutAddress_order_shipping_address_idToaddressInput[] | orderUncheckedCreateWithoutAddress_order_shipping_address_idToaddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddress_order_shipping_address_idToaddressInput | orderCreateOrConnectWithoutAddress_order_shipping_address_idToaddressInput[]
    createMany?: orderCreateManyAddress_order_shipping_address_idToaddressInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type app_userUpdateOneRequiredWithoutAddressNestedInput = {
    create?: XOR<app_userCreateWithoutAddressInput, app_userUncheckedCreateWithoutAddressInput>
    connectOrCreate?: app_userCreateOrConnectWithoutAddressInput
    upsert?: app_userUpsertWithoutAddressInput
    connect?: app_userWhereUniqueInput
    update?: XOR<XOR<app_userUpdateToOneWithWhereWithoutAddressInput, app_userUpdateWithoutAddressInput>, app_userUncheckedUpdateWithoutAddressInput>
  }

  export type checkout_sessionUpdateManyWithoutAddressNestedInput = {
    create?: XOR<checkout_sessionCreateWithoutAddressInput, checkout_sessionUncheckedCreateWithoutAddressInput> | checkout_sessionCreateWithoutAddressInput[] | checkout_sessionUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutAddressInput | checkout_sessionCreateOrConnectWithoutAddressInput[]
    upsert?: checkout_sessionUpsertWithWhereUniqueWithoutAddressInput | checkout_sessionUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: checkout_sessionCreateManyAddressInputEnvelope
    set?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    disconnect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    delete?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    update?: checkout_sessionUpdateWithWhereUniqueWithoutAddressInput | checkout_sessionUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: checkout_sessionUpdateManyWithWhereWithoutAddressInput | checkout_sessionUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: checkout_sessionScalarWhereInput | checkout_sessionScalarWhereInput[]
  }

  export type orderUpdateManyWithoutAddress_order_billing_address_idToaddressNestedInput = {
    create?: XOR<orderCreateWithoutAddress_order_billing_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_billing_address_idToaddressInput> | orderCreateWithoutAddress_order_billing_address_idToaddressInput[] | orderUncheckedCreateWithoutAddress_order_billing_address_idToaddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddress_order_billing_address_idToaddressInput | orderCreateOrConnectWithoutAddress_order_billing_address_idToaddressInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutAddress_order_billing_address_idToaddressInput | orderUpsertWithWhereUniqueWithoutAddress_order_billing_address_idToaddressInput[]
    createMany?: orderCreateManyAddress_order_billing_address_idToaddressInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutAddress_order_billing_address_idToaddressInput | orderUpdateWithWhereUniqueWithoutAddress_order_billing_address_idToaddressInput[]
    updateMany?: orderUpdateManyWithWhereWithoutAddress_order_billing_address_idToaddressInput | orderUpdateManyWithWhereWithoutAddress_order_billing_address_idToaddressInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type orderUpdateManyWithoutAddress_order_shipping_address_idToaddressNestedInput = {
    create?: XOR<orderCreateWithoutAddress_order_shipping_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_shipping_address_idToaddressInput> | orderCreateWithoutAddress_order_shipping_address_idToaddressInput[] | orderUncheckedCreateWithoutAddress_order_shipping_address_idToaddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddress_order_shipping_address_idToaddressInput | orderCreateOrConnectWithoutAddress_order_shipping_address_idToaddressInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutAddress_order_shipping_address_idToaddressInput | orderUpsertWithWhereUniqueWithoutAddress_order_shipping_address_idToaddressInput[]
    createMany?: orderCreateManyAddress_order_shipping_address_idToaddressInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutAddress_order_shipping_address_idToaddressInput | orderUpdateWithWhereUniqueWithoutAddress_order_shipping_address_idToaddressInput[]
    updateMany?: orderUpdateManyWithWhereWithoutAddress_order_shipping_address_idToaddressInput | orderUpdateManyWithWhereWithoutAddress_order_shipping_address_idToaddressInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type checkout_sessionUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<checkout_sessionCreateWithoutAddressInput, checkout_sessionUncheckedCreateWithoutAddressInput> | checkout_sessionCreateWithoutAddressInput[] | checkout_sessionUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutAddressInput | checkout_sessionCreateOrConnectWithoutAddressInput[]
    upsert?: checkout_sessionUpsertWithWhereUniqueWithoutAddressInput | checkout_sessionUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: checkout_sessionCreateManyAddressInputEnvelope
    set?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    disconnect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    delete?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    update?: checkout_sessionUpdateWithWhereUniqueWithoutAddressInput | checkout_sessionUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: checkout_sessionUpdateManyWithWhereWithoutAddressInput | checkout_sessionUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: checkout_sessionScalarWhereInput | checkout_sessionScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutAddress_order_billing_address_idToaddressNestedInput = {
    create?: XOR<orderCreateWithoutAddress_order_billing_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_billing_address_idToaddressInput> | orderCreateWithoutAddress_order_billing_address_idToaddressInput[] | orderUncheckedCreateWithoutAddress_order_billing_address_idToaddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddress_order_billing_address_idToaddressInput | orderCreateOrConnectWithoutAddress_order_billing_address_idToaddressInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutAddress_order_billing_address_idToaddressInput | orderUpsertWithWhereUniqueWithoutAddress_order_billing_address_idToaddressInput[]
    createMany?: orderCreateManyAddress_order_billing_address_idToaddressInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutAddress_order_billing_address_idToaddressInput | orderUpdateWithWhereUniqueWithoutAddress_order_billing_address_idToaddressInput[]
    updateMany?: orderUpdateManyWithWhereWithoutAddress_order_billing_address_idToaddressInput | orderUpdateManyWithWhereWithoutAddress_order_billing_address_idToaddressInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutAddress_order_shipping_address_idToaddressNestedInput = {
    create?: XOR<orderCreateWithoutAddress_order_shipping_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_shipping_address_idToaddressInput> | orderCreateWithoutAddress_order_shipping_address_idToaddressInput[] | orderUncheckedCreateWithoutAddress_order_shipping_address_idToaddressInput[]
    connectOrCreate?: orderCreateOrConnectWithoutAddress_order_shipping_address_idToaddressInput | orderCreateOrConnectWithoutAddress_order_shipping_address_idToaddressInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutAddress_order_shipping_address_idToaddressInput | orderUpsertWithWhereUniqueWithoutAddress_order_shipping_address_idToaddressInput[]
    createMany?: orderCreateManyAddress_order_shipping_address_idToaddressInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutAddress_order_shipping_address_idToaddressInput | orderUpdateWithWhereUniqueWithoutAddress_order_shipping_address_idToaddressInput[]
    updateMany?: orderUpdateManyWithWhereWithoutAddress_order_shipping_address_idToaddressInput | orderUpdateManyWithWhereWithoutAddress_order_shipping_address_idToaddressInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type cartCreateNestedOneWithoutCheckout_sessionInput = {
    create?: XOR<cartCreateWithoutCheckout_sessionInput, cartUncheckedCreateWithoutCheckout_sessionInput>
    connectOrCreate?: cartCreateOrConnectWithoutCheckout_sessionInput
    connect?: cartWhereUniqueInput
  }

  export type payment_cardCreateNestedOneWithoutCheckout_sessionInput = {
    create?: XOR<payment_cardCreateWithoutCheckout_sessionInput, payment_cardUncheckedCreateWithoutCheckout_sessionInput>
    connectOrCreate?: payment_cardCreateOrConnectWithoutCheckout_sessionInput
    connect?: payment_cardWhereUniqueInput
  }

  export type addressCreateNestedOneWithoutCheckout_sessionInput = {
    create?: XOR<addressCreateWithoutCheckout_sessionInput, addressUncheckedCreateWithoutCheckout_sessionInput>
    connectOrCreate?: addressCreateOrConnectWithoutCheckout_sessionInput
    connect?: addressWhereUniqueInput
  }

  export type app_userCreateNestedOneWithoutCheckout_sessionInput = {
    create?: XOR<app_userCreateWithoutCheckout_sessionInput, app_userUncheckedCreateWithoutCheckout_sessionInput>
    connectOrCreate?: app_userCreateOrConnectWithoutCheckout_sessionInput
    connect?: app_userWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type cartUpdateOneRequiredWithoutCheckout_sessionNestedInput = {
    create?: XOR<cartCreateWithoutCheckout_sessionInput, cartUncheckedCreateWithoutCheckout_sessionInput>
    connectOrCreate?: cartCreateOrConnectWithoutCheckout_sessionInput
    upsert?: cartUpsertWithoutCheckout_sessionInput
    connect?: cartWhereUniqueInput
    update?: XOR<XOR<cartUpdateToOneWithWhereWithoutCheckout_sessionInput, cartUpdateWithoutCheckout_sessionInput>, cartUncheckedUpdateWithoutCheckout_sessionInput>
  }

  export type payment_cardUpdateOneWithoutCheckout_sessionNestedInput = {
    create?: XOR<payment_cardCreateWithoutCheckout_sessionInput, payment_cardUncheckedCreateWithoutCheckout_sessionInput>
    connectOrCreate?: payment_cardCreateOrConnectWithoutCheckout_sessionInput
    upsert?: payment_cardUpsertWithoutCheckout_sessionInput
    disconnect?: payment_cardWhereInput | boolean
    delete?: payment_cardWhereInput | boolean
    connect?: payment_cardWhereUniqueInput
    update?: XOR<XOR<payment_cardUpdateToOneWithWhereWithoutCheckout_sessionInput, payment_cardUpdateWithoutCheckout_sessionInput>, payment_cardUncheckedUpdateWithoutCheckout_sessionInput>
  }

  export type addressUpdateOneWithoutCheckout_sessionNestedInput = {
    create?: XOR<addressCreateWithoutCheckout_sessionInput, addressUncheckedCreateWithoutCheckout_sessionInput>
    connectOrCreate?: addressCreateOrConnectWithoutCheckout_sessionInput
    upsert?: addressUpsertWithoutCheckout_sessionInput
    disconnect?: addressWhereInput | boolean
    delete?: addressWhereInput | boolean
    connect?: addressWhereUniqueInput
    update?: XOR<XOR<addressUpdateToOneWithWhereWithoutCheckout_sessionInput, addressUpdateWithoutCheckout_sessionInput>, addressUncheckedUpdateWithoutCheckout_sessionInput>
  }

  export type app_userUpdateOneRequiredWithoutCheckout_sessionNestedInput = {
    create?: XOR<app_userCreateWithoutCheckout_sessionInput, app_userUncheckedCreateWithoutCheckout_sessionInput>
    connectOrCreate?: app_userCreateOrConnectWithoutCheckout_sessionInput
    upsert?: app_userUpsertWithoutCheckout_sessionInput
    connect?: app_userWhereUniqueInput
    update?: XOR<XOR<app_userUpdateToOneWithWhereWithoutCheckout_sessionInput, app_userUpdateWithoutCheckout_sessionInput>, app_userUncheckedUpdateWithoutCheckout_sessionInput>
  }

  export type checkout_sessionCreateNestedManyWithoutPayment_cardInput = {
    create?: XOR<checkout_sessionCreateWithoutPayment_cardInput, checkout_sessionUncheckedCreateWithoutPayment_cardInput> | checkout_sessionCreateWithoutPayment_cardInput[] | checkout_sessionUncheckedCreateWithoutPayment_cardInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutPayment_cardInput | checkout_sessionCreateOrConnectWithoutPayment_cardInput[]
    createMany?: checkout_sessionCreateManyPayment_cardInputEnvelope
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
  }

  export type orderCreateNestedManyWithoutPayment_cardInput = {
    create?: XOR<orderCreateWithoutPayment_cardInput, orderUncheckedCreateWithoutPayment_cardInput> | orderCreateWithoutPayment_cardInput[] | orderUncheckedCreateWithoutPayment_cardInput[]
    connectOrCreate?: orderCreateOrConnectWithoutPayment_cardInput | orderCreateOrConnectWithoutPayment_cardInput[]
    createMany?: orderCreateManyPayment_cardInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type app_userCreateNestedOneWithoutPayment_cardInput = {
    create?: XOR<app_userCreateWithoutPayment_cardInput, app_userUncheckedCreateWithoutPayment_cardInput>
    connectOrCreate?: app_userCreateOrConnectWithoutPayment_cardInput
    connect?: app_userWhereUniqueInput
  }

  export type checkout_sessionUncheckedCreateNestedManyWithoutPayment_cardInput = {
    create?: XOR<checkout_sessionCreateWithoutPayment_cardInput, checkout_sessionUncheckedCreateWithoutPayment_cardInput> | checkout_sessionCreateWithoutPayment_cardInput[] | checkout_sessionUncheckedCreateWithoutPayment_cardInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutPayment_cardInput | checkout_sessionCreateOrConnectWithoutPayment_cardInput[]
    createMany?: checkout_sessionCreateManyPayment_cardInputEnvelope
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
  }

  export type orderUncheckedCreateNestedManyWithoutPayment_cardInput = {
    create?: XOR<orderCreateWithoutPayment_cardInput, orderUncheckedCreateWithoutPayment_cardInput> | orderCreateWithoutPayment_cardInput[] | orderUncheckedCreateWithoutPayment_cardInput[]
    connectOrCreate?: orderCreateOrConnectWithoutPayment_cardInput | orderCreateOrConnectWithoutPayment_cardInput[]
    createMany?: orderCreateManyPayment_cardInputEnvelope
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
  }

  export type checkout_sessionUpdateManyWithoutPayment_cardNestedInput = {
    create?: XOR<checkout_sessionCreateWithoutPayment_cardInput, checkout_sessionUncheckedCreateWithoutPayment_cardInput> | checkout_sessionCreateWithoutPayment_cardInput[] | checkout_sessionUncheckedCreateWithoutPayment_cardInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutPayment_cardInput | checkout_sessionCreateOrConnectWithoutPayment_cardInput[]
    upsert?: checkout_sessionUpsertWithWhereUniqueWithoutPayment_cardInput | checkout_sessionUpsertWithWhereUniqueWithoutPayment_cardInput[]
    createMany?: checkout_sessionCreateManyPayment_cardInputEnvelope
    set?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    disconnect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    delete?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    update?: checkout_sessionUpdateWithWhereUniqueWithoutPayment_cardInput | checkout_sessionUpdateWithWhereUniqueWithoutPayment_cardInput[]
    updateMany?: checkout_sessionUpdateManyWithWhereWithoutPayment_cardInput | checkout_sessionUpdateManyWithWhereWithoutPayment_cardInput[]
    deleteMany?: checkout_sessionScalarWhereInput | checkout_sessionScalarWhereInput[]
  }

  export type orderUpdateManyWithoutPayment_cardNestedInput = {
    create?: XOR<orderCreateWithoutPayment_cardInput, orderUncheckedCreateWithoutPayment_cardInput> | orderCreateWithoutPayment_cardInput[] | orderUncheckedCreateWithoutPayment_cardInput[]
    connectOrCreate?: orderCreateOrConnectWithoutPayment_cardInput | orderCreateOrConnectWithoutPayment_cardInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutPayment_cardInput | orderUpsertWithWhereUniqueWithoutPayment_cardInput[]
    createMany?: orderCreateManyPayment_cardInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutPayment_cardInput | orderUpdateWithWhereUniqueWithoutPayment_cardInput[]
    updateMany?: orderUpdateManyWithWhereWithoutPayment_cardInput | orderUpdateManyWithWhereWithoutPayment_cardInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type app_userUpdateOneRequiredWithoutPayment_cardNestedInput = {
    create?: XOR<app_userCreateWithoutPayment_cardInput, app_userUncheckedCreateWithoutPayment_cardInput>
    connectOrCreate?: app_userCreateOrConnectWithoutPayment_cardInput
    upsert?: app_userUpsertWithoutPayment_cardInput
    connect?: app_userWhereUniqueInput
    update?: XOR<XOR<app_userUpdateToOneWithWhereWithoutPayment_cardInput, app_userUpdateWithoutPayment_cardInput>, app_userUncheckedUpdateWithoutPayment_cardInput>
  }

  export type checkout_sessionUncheckedUpdateManyWithoutPayment_cardNestedInput = {
    create?: XOR<checkout_sessionCreateWithoutPayment_cardInput, checkout_sessionUncheckedCreateWithoutPayment_cardInput> | checkout_sessionCreateWithoutPayment_cardInput[] | checkout_sessionUncheckedCreateWithoutPayment_cardInput[]
    connectOrCreate?: checkout_sessionCreateOrConnectWithoutPayment_cardInput | checkout_sessionCreateOrConnectWithoutPayment_cardInput[]
    upsert?: checkout_sessionUpsertWithWhereUniqueWithoutPayment_cardInput | checkout_sessionUpsertWithWhereUniqueWithoutPayment_cardInput[]
    createMany?: checkout_sessionCreateManyPayment_cardInputEnvelope
    set?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    disconnect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    delete?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    connect?: checkout_sessionWhereUniqueInput | checkout_sessionWhereUniqueInput[]
    update?: checkout_sessionUpdateWithWhereUniqueWithoutPayment_cardInput | checkout_sessionUpdateWithWhereUniqueWithoutPayment_cardInput[]
    updateMany?: checkout_sessionUpdateManyWithWhereWithoutPayment_cardInput | checkout_sessionUpdateManyWithWhereWithoutPayment_cardInput[]
    deleteMany?: checkout_sessionScalarWhereInput | checkout_sessionScalarWhereInput[]
  }

  export type orderUncheckedUpdateManyWithoutPayment_cardNestedInput = {
    create?: XOR<orderCreateWithoutPayment_cardInput, orderUncheckedCreateWithoutPayment_cardInput> | orderCreateWithoutPayment_cardInput[] | orderUncheckedCreateWithoutPayment_cardInput[]
    connectOrCreate?: orderCreateOrConnectWithoutPayment_cardInput | orderCreateOrConnectWithoutPayment_cardInput[]
    upsert?: orderUpsertWithWhereUniqueWithoutPayment_cardInput | orderUpsertWithWhereUniqueWithoutPayment_cardInput[]
    createMany?: orderCreateManyPayment_cardInputEnvelope
    set?: orderWhereUniqueInput | orderWhereUniqueInput[]
    disconnect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    delete?: orderWhereUniqueInput | orderWhereUniqueInput[]
    connect?: orderWhereUniqueInput | orderWhereUniqueInput[]
    update?: orderUpdateWithWhereUniqueWithoutPayment_cardInput | orderUpdateWithWhereUniqueWithoutPayment_cardInput[]
    updateMany?: orderUpdateManyWithWhereWithoutPayment_cardInput | orderUpdateManyWithWhereWithoutPayment_cardInput[]
    deleteMany?: orderScalarWhereInput | orderScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type addressCreateWithoutApp_userInput = {
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    unit?: string | null
    checkout_session?: checkout_sessionCreateNestedManyWithoutAddressInput
    order_order_billing_address_idToaddress?: orderCreateNestedManyWithoutAddress_order_billing_address_idToaddressInput
    order_order_shipping_address_idToaddress?: orderCreateNestedManyWithoutAddress_order_shipping_address_idToaddressInput
  }

  export type addressUncheckedCreateWithoutApp_userInput = {
    id?: number
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    unit?: string | null
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutAddressInput
    order_order_billing_address_idToaddress?: orderUncheckedCreateNestedManyWithoutAddress_order_billing_address_idToaddressInput
    order_order_shipping_address_idToaddress?: orderUncheckedCreateNestedManyWithoutAddress_order_shipping_address_idToaddressInput
  }

  export type addressCreateOrConnectWithoutApp_userInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutApp_userInput, addressUncheckedCreateWithoutApp_userInput>
  }

  export type addressCreateManyApp_userInputEnvelope = {
    data: addressCreateManyApp_userInput | addressCreateManyApp_userInput[]
    skipDuplicates?: boolean
  }

  export type cartCreateWithoutApp_userInput = {
    num_items?: number
    total?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    cart_product?: cart_productCreateNestedManyWithoutCartInput
    checkout_session?: checkout_sessionCreateNestedManyWithoutCartInput
  }

  export type cartUncheckedCreateWithoutApp_userInput = {
    id?: number
    num_items?: number
    total?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    cart_product?: cart_productUncheckedCreateNestedManyWithoutCartInput
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutCartInput
  }

  export type cartCreateOrConnectWithoutApp_userInput = {
    where: cartWhereUniqueInput
    create: XOR<cartCreateWithoutApp_userInput, cartUncheckedCreateWithoutApp_userInput>
  }

  export type cartCreateManyApp_userInputEnvelope = {
    data: cartCreateManyApp_userInput | cartCreateManyApp_userInput[]
    skipDuplicates?: boolean
  }

  export type checkout_sessionCreateWithoutApp_userInput = {
    stage?: string
    billing_address_id?: number | null
    cart: cartCreateNestedOneWithoutCheckout_sessionInput
    payment_card?: payment_cardCreateNestedOneWithoutCheckout_sessionInput
    address?: addressCreateNestedOneWithoutCheckout_sessionInput
  }

  export type checkout_sessionUncheckedCreateWithoutApp_userInput = {
    id?: number
    payment_card_id?: number | null
    shipping_address_id?: number | null
    cart_id: number
    stage?: string
    billing_address_id?: number | null
  }

  export type checkout_sessionCreateOrConnectWithoutApp_userInput = {
    where: checkout_sessionWhereUniqueInput
    create: XOR<checkout_sessionCreateWithoutApp_userInput, checkout_sessionUncheckedCreateWithoutApp_userInput>
  }

  export type checkout_sessionCreateManyApp_userInputEnvelope = {
    data: checkout_sessionCreateManyApp_userInput | checkout_sessionCreateManyApp_userInput[]
    skipDuplicates?: boolean
  }

  export type orderCreateWithoutApp_userInput = {
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    address_order_billing_address_idToaddress: addressCreateNestedOneWithoutOrder_order_billing_address_idToaddressInput
    payment_card: payment_cardCreateNestedOneWithoutOrderInput
    address_order_shipping_address_idToaddress: addressCreateNestedOneWithoutOrder_order_shipping_address_idToaddressInput
    order_product?: order_productCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutApp_userInput = {
    id?: number
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    payment_card_id: number
    shipping_address_id: number
    billing_address_id: number
    order_product?: order_productUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutApp_userInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutApp_userInput, orderUncheckedCreateWithoutApp_userInput>
  }

  export type orderCreateManyApp_userInputEnvelope = {
    data: orderCreateManyApp_userInput | orderCreateManyApp_userInput[]
    skipDuplicates?: boolean
  }

  export type payment_cardCreateWithoutApp_userInput = {
    card_number: string
    security_code: string
    expiration_month: string
    expiration_year: string
    first_name: string
    last_name: string
    payment_card_type: string
    checkout_session?: checkout_sessionCreateNestedManyWithoutPayment_cardInput
    order?: orderCreateNestedManyWithoutPayment_cardInput
  }

  export type payment_cardUncheckedCreateWithoutApp_userInput = {
    id?: number
    card_number: string
    security_code: string
    expiration_month: string
    expiration_year: string
    first_name: string
    last_name: string
    payment_card_type: string
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutPayment_cardInput
    order?: orderUncheckedCreateNestedManyWithoutPayment_cardInput
  }

  export type payment_cardCreateOrConnectWithoutApp_userInput = {
    where: payment_cardWhereUniqueInput
    create: XOR<payment_cardCreateWithoutApp_userInput, payment_cardUncheckedCreateWithoutApp_userInput>
  }

  export type payment_cardCreateManyApp_userInputEnvelope = {
    data: payment_cardCreateManyApp_userInput | payment_cardCreateManyApp_userInput[]
    skipDuplicates?: boolean
  }

  export type addressUpsertWithWhereUniqueWithoutApp_userInput = {
    where: addressWhereUniqueInput
    update: XOR<addressUpdateWithoutApp_userInput, addressUncheckedUpdateWithoutApp_userInput>
    create: XOR<addressCreateWithoutApp_userInput, addressUncheckedCreateWithoutApp_userInput>
  }

  export type addressUpdateWithWhereUniqueWithoutApp_userInput = {
    where: addressWhereUniqueInput
    data: XOR<addressUpdateWithoutApp_userInput, addressUncheckedUpdateWithoutApp_userInput>
  }

  export type addressUpdateManyWithWhereWithoutApp_userInput = {
    where: addressScalarWhereInput
    data: XOR<addressUpdateManyMutationInput, addressUncheckedUpdateManyWithoutApp_userInput>
  }

  export type addressScalarWhereInput = {
    AND?: addressScalarWhereInput | addressScalarWhereInput[]
    OR?: addressScalarWhereInput[]
    NOT?: addressScalarWhereInput | addressScalarWhereInput[]
    id?: IntFilter<"address"> | number
    first_name?: StringFilter<"address"> | string
    last_name?: StringFilter<"address"> | string
    address?: StringFilter<"address"> | string
    city?: StringFilter<"address"> | string
    province?: StringFilter<"address"> | string
    country?: StringFilter<"address"> | string
    postal_code?: StringFilter<"address"> | string
    phone_number?: StringFilter<"address"> | string
    address_type?: StringFilter<"address"> | string
    user_id?: IntFilter<"address"> | number
    unit?: StringNullableFilter<"address"> | string | null
  }

  export type cartUpsertWithWhereUniqueWithoutApp_userInput = {
    where: cartWhereUniqueInput
    update: XOR<cartUpdateWithoutApp_userInput, cartUncheckedUpdateWithoutApp_userInput>
    create: XOR<cartCreateWithoutApp_userInput, cartUncheckedCreateWithoutApp_userInput>
  }

  export type cartUpdateWithWhereUniqueWithoutApp_userInput = {
    where: cartWhereUniqueInput
    data: XOR<cartUpdateWithoutApp_userInput, cartUncheckedUpdateWithoutApp_userInput>
  }

  export type cartUpdateManyWithWhereWithoutApp_userInput = {
    where: cartScalarWhereInput
    data: XOR<cartUpdateManyMutationInput, cartUncheckedUpdateManyWithoutApp_userInput>
  }

  export type cartScalarWhereInput = {
    AND?: cartScalarWhereInput | cartScalarWhereInput[]
    OR?: cartScalarWhereInput[]
    NOT?: cartScalarWhereInput | cartScalarWhereInput[]
    id?: IntFilter<"cart"> | number
    user_id?: IntFilter<"cart"> | number
    num_items?: IntFilter<"cart"> | number
    total?: DecimalFilter<"cart"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"cart"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFilter<"cart"> | Decimal | DecimalJsLike | number | string
  }

  export type checkout_sessionUpsertWithWhereUniqueWithoutApp_userInput = {
    where: checkout_sessionWhereUniqueInput
    update: XOR<checkout_sessionUpdateWithoutApp_userInput, checkout_sessionUncheckedUpdateWithoutApp_userInput>
    create: XOR<checkout_sessionCreateWithoutApp_userInput, checkout_sessionUncheckedCreateWithoutApp_userInput>
  }

  export type checkout_sessionUpdateWithWhereUniqueWithoutApp_userInput = {
    where: checkout_sessionWhereUniqueInput
    data: XOR<checkout_sessionUpdateWithoutApp_userInput, checkout_sessionUncheckedUpdateWithoutApp_userInput>
  }

  export type checkout_sessionUpdateManyWithWhereWithoutApp_userInput = {
    where: checkout_sessionScalarWhereInput
    data: XOR<checkout_sessionUpdateManyMutationInput, checkout_sessionUncheckedUpdateManyWithoutApp_userInput>
  }

  export type checkout_sessionScalarWhereInput = {
    AND?: checkout_sessionScalarWhereInput | checkout_sessionScalarWhereInput[]
    OR?: checkout_sessionScalarWhereInput[]
    NOT?: checkout_sessionScalarWhereInput | checkout_sessionScalarWhereInput[]
    id?: IntFilter<"checkout_session"> | number
    user_id?: IntFilter<"checkout_session"> | number
    payment_card_id?: IntNullableFilter<"checkout_session"> | number | null
    shipping_address_id?: IntNullableFilter<"checkout_session"> | number | null
    cart_id?: IntFilter<"checkout_session"> | number
    stage?: StringFilter<"checkout_session"> | string
    billing_address_id?: IntNullableFilter<"checkout_session"> | number | null
  }

  export type orderUpsertWithWhereUniqueWithoutApp_userInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutApp_userInput, orderUncheckedUpdateWithoutApp_userInput>
    create: XOR<orderCreateWithoutApp_userInput, orderUncheckedCreateWithoutApp_userInput>
  }

  export type orderUpdateWithWhereUniqueWithoutApp_userInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutApp_userInput, orderUncheckedUpdateWithoutApp_userInput>
  }

  export type orderUpdateManyWithWhereWithoutApp_userInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutApp_userInput>
  }

  export type orderScalarWhereInput = {
    AND?: orderScalarWhereInput | orderScalarWhereInput[]
    OR?: orderScalarWhereInput[]
    NOT?: orderScalarWhereInput | orderScalarWhereInput[]
    id?: IntFilter<"order"> | number
    user_id?: IntFilter<"order"> | number
    order_date?: DateTimeFilter<"order"> | Date | string
    total?: DecimalFilter<"order"> | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFilter<"order"> | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFilter<"order"> | Decimal | DecimalJsLike | number | string
    num_items?: IntFilter<"order"> | number
    payment_card_id?: IntFilter<"order"> | number
    shipping_address_id?: IntFilter<"order"> | number
    billing_address_id?: IntFilter<"order"> | number
  }

  export type payment_cardUpsertWithWhereUniqueWithoutApp_userInput = {
    where: payment_cardWhereUniqueInput
    update: XOR<payment_cardUpdateWithoutApp_userInput, payment_cardUncheckedUpdateWithoutApp_userInput>
    create: XOR<payment_cardCreateWithoutApp_userInput, payment_cardUncheckedCreateWithoutApp_userInput>
  }

  export type payment_cardUpdateWithWhereUniqueWithoutApp_userInput = {
    where: payment_cardWhereUniqueInput
    data: XOR<payment_cardUpdateWithoutApp_userInput, payment_cardUncheckedUpdateWithoutApp_userInput>
  }

  export type payment_cardUpdateManyWithWhereWithoutApp_userInput = {
    where: payment_cardScalarWhereInput
    data: XOR<payment_cardUpdateManyMutationInput, payment_cardUncheckedUpdateManyWithoutApp_userInput>
  }

  export type payment_cardScalarWhereInput = {
    AND?: payment_cardScalarWhereInput | payment_cardScalarWhereInput[]
    OR?: payment_cardScalarWhereInput[]
    NOT?: payment_cardScalarWhereInput | payment_cardScalarWhereInput[]
    id?: IntFilter<"payment_card"> | number
    user_id?: IntFilter<"payment_card"> | number
    card_number?: StringFilter<"payment_card"> | string
    security_code?: StringFilter<"payment_card"> | string
    expiration_month?: StringFilter<"payment_card"> | string
    expiration_year?: StringFilter<"payment_card"> | string
    first_name?: StringFilter<"payment_card"> | string
    last_name?: StringFilter<"payment_card"> | string
    payment_card_type?: StringFilter<"payment_card"> | string
  }

  export type app_userCreateWithoutCartInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    address?: addressCreateNestedManyWithoutApp_userInput
    checkout_session?: checkout_sessionCreateNestedManyWithoutApp_userInput
    order?: orderCreateNestedManyWithoutApp_userInput
    payment_card?: payment_cardCreateNestedManyWithoutApp_userInput
  }

  export type app_userUncheckedCreateWithoutCartInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    address?: addressUncheckedCreateNestedManyWithoutApp_userInput
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutApp_userInput
    order?: orderUncheckedCreateNestedManyWithoutApp_userInput
    payment_card?: payment_cardUncheckedCreateNestedManyWithoutApp_userInput
  }

  export type app_userCreateOrConnectWithoutCartInput = {
    where: app_userWhereUniqueInput
    create: XOR<app_userCreateWithoutCartInput, app_userUncheckedCreateWithoutCartInput>
  }

  export type cart_productCreateWithoutCartInput = {
    quantity?: number
    product: productCreateNestedOneWithoutCart_productInput
  }

  export type cart_productUncheckedCreateWithoutCartInput = {
    product_id: number
    quantity?: number
  }

  export type cart_productCreateOrConnectWithoutCartInput = {
    where: cart_productWhereUniqueInput
    create: XOR<cart_productCreateWithoutCartInput, cart_productUncheckedCreateWithoutCartInput>
  }

  export type cart_productCreateManyCartInputEnvelope = {
    data: cart_productCreateManyCartInput | cart_productCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type checkout_sessionCreateWithoutCartInput = {
    stage?: string
    billing_address_id?: number | null
    payment_card?: payment_cardCreateNestedOneWithoutCheckout_sessionInput
    address?: addressCreateNestedOneWithoutCheckout_sessionInput
    app_user: app_userCreateNestedOneWithoutCheckout_sessionInput
  }

  export type checkout_sessionUncheckedCreateWithoutCartInput = {
    id?: number
    user_id: number
    payment_card_id?: number | null
    shipping_address_id?: number | null
    stage?: string
    billing_address_id?: number | null
  }

  export type checkout_sessionCreateOrConnectWithoutCartInput = {
    where: checkout_sessionWhereUniqueInput
    create: XOR<checkout_sessionCreateWithoutCartInput, checkout_sessionUncheckedCreateWithoutCartInput>
  }

  export type checkout_sessionCreateManyCartInputEnvelope = {
    data: checkout_sessionCreateManyCartInput | checkout_sessionCreateManyCartInput[]
    skipDuplicates?: boolean
  }

  export type app_userUpsertWithoutCartInput = {
    update: XOR<app_userUpdateWithoutCartInput, app_userUncheckedUpdateWithoutCartInput>
    create: XOR<app_userCreateWithoutCartInput, app_userUncheckedCreateWithoutCartInput>
    where?: app_userWhereInput
  }

  export type app_userUpdateToOneWithWhereWithoutCartInput = {
    where?: app_userWhereInput
    data: XOR<app_userUpdateWithoutCartInput, app_userUncheckedUpdateWithoutCartInput>
  }

  export type app_userUpdateWithoutCartInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: addressUpdateManyWithoutApp_userNestedInput
    checkout_session?: checkout_sessionUpdateManyWithoutApp_userNestedInput
    order?: orderUpdateManyWithoutApp_userNestedInput
    payment_card?: payment_cardUpdateManyWithoutApp_userNestedInput
  }

  export type app_userUncheckedUpdateWithoutCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: addressUncheckedUpdateManyWithoutApp_userNestedInput
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutApp_userNestedInput
    order?: orderUncheckedUpdateManyWithoutApp_userNestedInput
    payment_card?: payment_cardUncheckedUpdateManyWithoutApp_userNestedInput
  }

  export type cart_productUpsertWithWhereUniqueWithoutCartInput = {
    where: cart_productWhereUniqueInput
    update: XOR<cart_productUpdateWithoutCartInput, cart_productUncheckedUpdateWithoutCartInput>
    create: XOR<cart_productCreateWithoutCartInput, cart_productUncheckedCreateWithoutCartInput>
  }

  export type cart_productUpdateWithWhereUniqueWithoutCartInput = {
    where: cart_productWhereUniqueInput
    data: XOR<cart_productUpdateWithoutCartInput, cart_productUncheckedUpdateWithoutCartInput>
  }

  export type cart_productUpdateManyWithWhereWithoutCartInput = {
    where: cart_productScalarWhereInput
    data: XOR<cart_productUpdateManyMutationInput, cart_productUncheckedUpdateManyWithoutCartInput>
  }

  export type cart_productScalarWhereInput = {
    AND?: cart_productScalarWhereInput | cart_productScalarWhereInput[]
    OR?: cart_productScalarWhereInput[]
    NOT?: cart_productScalarWhereInput | cart_productScalarWhereInput[]
    product_id?: IntFilter<"cart_product"> | number
    cart_id?: IntFilter<"cart_product"> | number
    quantity?: IntFilter<"cart_product"> | number
  }

  export type checkout_sessionUpsertWithWhereUniqueWithoutCartInput = {
    where: checkout_sessionWhereUniqueInput
    update: XOR<checkout_sessionUpdateWithoutCartInput, checkout_sessionUncheckedUpdateWithoutCartInput>
    create: XOR<checkout_sessionCreateWithoutCartInput, checkout_sessionUncheckedCreateWithoutCartInput>
  }

  export type checkout_sessionUpdateWithWhereUniqueWithoutCartInput = {
    where: checkout_sessionWhereUniqueInput
    data: XOR<checkout_sessionUpdateWithoutCartInput, checkout_sessionUncheckedUpdateWithoutCartInput>
  }

  export type checkout_sessionUpdateManyWithWhereWithoutCartInput = {
    where: checkout_sessionScalarWhereInput
    data: XOR<checkout_sessionUpdateManyMutationInput, checkout_sessionUncheckedUpdateManyWithoutCartInput>
  }

  export type cartCreateWithoutCart_productInput = {
    num_items?: number
    total?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    app_user: app_userCreateNestedOneWithoutCartInput
    checkout_session?: checkout_sessionCreateNestedManyWithoutCartInput
  }

  export type cartUncheckedCreateWithoutCart_productInput = {
    id?: number
    user_id: number
    num_items?: number
    total?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutCartInput
  }

  export type cartCreateOrConnectWithoutCart_productInput = {
    where: cartWhereUniqueInput
    create: XOR<cartCreateWithoutCart_productInput, cartUncheckedCreateWithoutCart_productInput>
  }

  export type productCreateWithoutCart_productInput = {
    name: string
    description: string
    inventory?: number
    price: Decimal | DecimalJsLike | number | string
    category_code: string
    discount_type?: string
    total_sold?: number
    img_filename: string
    discount_percent?: number
    item_code: string
    order_product?: order_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutCart_productInput = {
    id?: number
    name: string
    description: string
    inventory?: number
    price: Decimal | DecimalJsLike | number | string
    category_code: string
    discount_type?: string
    total_sold?: number
    img_filename: string
    discount_percent?: number
    item_code: string
    order_product?: order_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutCart_productInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutCart_productInput, productUncheckedCreateWithoutCart_productInput>
  }

  export type cartUpsertWithoutCart_productInput = {
    update: XOR<cartUpdateWithoutCart_productInput, cartUncheckedUpdateWithoutCart_productInput>
    create: XOR<cartCreateWithoutCart_productInput, cartUncheckedCreateWithoutCart_productInput>
    where?: cartWhereInput
  }

  export type cartUpdateToOneWithWhereWithoutCart_productInput = {
    where?: cartWhereInput
    data: XOR<cartUpdateWithoutCart_productInput, cartUncheckedUpdateWithoutCart_productInput>
  }

  export type cartUpdateWithoutCart_productInput = {
    num_items?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    app_user?: app_userUpdateOneRequiredWithoutCartNestedInput
    checkout_session?: checkout_sessionUpdateManyWithoutCartNestedInput
  }

  export type cartUncheckedUpdateWithoutCart_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    num_items?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutCartNestedInput
  }

  export type productUpsertWithoutCart_productInput = {
    update: XOR<productUpdateWithoutCart_productInput, productUncheckedUpdateWithoutCart_productInput>
    create: XOR<productCreateWithoutCart_productInput, productUncheckedCreateWithoutCart_productInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutCart_productInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutCart_productInput, productUncheckedUpdateWithoutCart_productInput>
  }

  export type productUpdateWithoutCart_productInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category_code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    total_sold?: IntFieldUpdateOperationsInput | number
    img_filename?: StringFieldUpdateOperationsInput | string
    discount_percent?: IntFieldUpdateOperationsInput | number
    item_code?: StringFieldUpdateOperationsInput | string
    order_product?: order_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutCart_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category_code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    total_sold?: IntFieldUpdateOperationsInput | number
    img_filename?: StringFieldUpdateOperationsInput | string
    discount_percent?: IntFieldUpdateOperationsInput | number
    item_code?: StringFieldUpdateOperationsInput | string
    order_product?: order_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type addressCreateWithoutOrder_order_billing_address_idToaddressInput = {
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    unit?: string | null
    app_user: app_userCreateNestedOneWithoutAddressInput
    checkout_session?: checkout_sessionCreateNestedManyWithoutAddressInput
    order_order_shipping_address_idToaddress?: orderCreateNestedManyWithoutAddress_order_shipping_address_idToaddressInput
  }

  export type addressUncheckedCreateWithoutOrder_order_billing_address_idToaddressInput = {
    id?: number
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    user_id: number
    unit?: string | null
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutAddressInput
    order_order_shipping_address_idToaddress?: orderUncheckedCreateNestedManyWithoutAddress_order_shipping_address_idToaddressInput
  }

  export type addressCreateOrConnectWithoutOrder_order_billing_address_idToaddressInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutOrder_order_billing_address_idToaddressInput, addressUncheckedCreateWithoutOrder_order_billing_address_idToaddressInput>
  }

  export type payment_cardCreateWithoutOrderInput = {
    card_number: string
    security_code: string
    expiration_month: string
    expiration_year: string
    first_name: string
    last_name: string
    payment_card_type: string
    checkout_session?: checkout_sessionCreateNestedManyWithoutPayment_cardInput
    app_user: app_userCreateNestedOneWithoutPayment_cardInput
  }

  export type payment_cardUncheckedCreateWithoutOrderInput = {
    id?: number
    user_id: number
    card_number: string
    security_code: string
    expiration_month: string
    expiration_year: string
    first_name: string
    last_name: string
    payment_card_type: string
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutPayment_cardInput
  }

  export type payment_cardCreateOrConnectWithoutOrderInput = {
    where: payment_cardWhereUniqueInput
    create: XOR<payment_cardCreateWithoutOrderInput, payment_cardUncheckedCreateWithoutOrderInput>
  }

  export type addressCreateWithoutOrder_order_shipping_address_idToaddressInput = {
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    unit?: string | null
    app_user: app_userCreateNestedOneWithoutAddressInput
    checkout_session?: checkout_sessionCreateNestedManyWithoutAddressInput
    order_order_billing_address_idToaddress?: orderCreateNestedManyWithoutAddress_order_billing_address_idToaddressInput
  }

  export type addressUncheckedCreateWithoutOrder_order_shipping_address_idToaddressInput = {
    id?: number
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    user_id: number
    unit?: string | null
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutAddressInput
    order_order_billing_address_idToaddress?: orderUncheckedCreateNestedManyWithoutAddress_order_billing_address_idToaddressInput
  }

  export type addressCreateOrConnectWithoutOrder_order_shipping_address_idToaddressInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutOrder_order_shipping_address_idToaddressInput, addressUncheckedCreateWithoutOrder_order_shipping_address_idToaddressInput>
  }

  export type app_userCreateWithoutOrderInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    address?: addressCreateNestedManyWithoutApp_userInput
    cart?: cartCreateNestedManyWithoutApp_userInput
    checkout_session?: checkout_sessionCreateNestedManyWithoutApp_userInput
    payment_card?: payment_cardCreateNestedManyWithoutApp_userInput
  }

  export type app_userUncheckedCreateWithoutOrderInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    address?: addressUncheckedCreateNestedManyWithoutApp_userInput
    cart?: cartUncheckedCreateNestedManyWithoutApp_userInput
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutApp_userInput
    payment_card?: payment_cardUncheckedCreateNestedManyWithoutApp_userInput
  }

  export type app_userCreateOrConnectWithoutOrderInput = {
    where: app_userWhereUniqueInput
    create: XOR<app_userCreateWithoutOrderInput, app_userUncheckedCreateWithoutOrderInput>
  }

  export type order_productCreateWithoutOrderInput = {
    quantity: number
    product: productCreateNestedOneWithoutOrder_productInput
  }

  export type order_productUncheckedCreateWithoutOrderInput = {
    product_id: number
    quantity: number
  }

  export type order_productCreateOrConnectWithoutOrderInput = {
    where: order_productWhereUniqueInput
    create: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput>
  }

  export type order_productCreateManyOrderInputEnvelope = {
    data: order_productCreateManyOrderInput | order_productCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type addressUpsertWithoutOrder_order_billing_address_idToaddressInput = {
    update: XOR<addressUpdateWithoutOrder_order_billing_address_idToaddressInput, addressUncheckedUpdateWithoutOrder_order_billing_address_idToaddressInput>
    create: XOR<addressCreateWithoutOrder_order_billing_address_idToaddressInput, addressUncheckedCreateWithoutOrder_order_billing_address_idToaddressInput>
    where?: addressWhereInput
  }

  export type addressUpdateToOneWithWhereWithoutOrder_order_billing_address_idToaddressInput = {
    where?: addressWhereInput
    data: XOR<addressUpdateWithoutOrder_order_billing_address_idToaddressInput, addressUncheckedUpdateWithoutOrder_order_billing_address_idToaddressInput>
  }

  export type addressUpdateWithoutOrder_order_billing_address_idToaddressInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    app_user?: app_userUpdateOneRequiredWithoutAddressNestedInput
    checkout_session?: checkout_sessionUpdateManyWithoutAddressNestedInput
    order_order_shipping_address_idToaddress?: orderUpdateManyWithoutAddress_order_shipping_address_idToaddressNestedInput
  }

  export type addressUncheckedUpdateWithoutOrder_order_billing_address_idToaddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutAddressNestedInput
    order_order_shipping_address_idToaddress?: orderUncheckedUpdateManyWithoutAddress_order_shipping_address_idToaddressNestedInput
  }

  export type payment_cardUpsertWithoutOrderInput = {
    update: XOR<payment_cardUpdateWithoutOrderInput, payment_cardUncheckedUpdateWithoutOrderInput>
    create: XOR<payment_cardCreateWithoutOrderInput, payment_cardUncheckedCreateWithoutOrderInput>
    where?: payment_cardWhereInput
  }

  export type payment_cardUpdateToOneWithWhereWithoutOrderInput = {
    where?: payment_cardWhereInput
    data: XOR<payment_cardUpdateWithoutOrderInput, payment_cardUncheckedUpdateWithoutOrderInput>
  }

  export type payment_cardUpdateWithoutOrderInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    security_code?: StringFieldUpdateOperationsInput | string
    expiration_month?: StringFieldUpdateOperationsInput | string
    expiration_year?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    payment_card_type?: StringFieldUpdateOperationsInput | string
    checkout_session?: checkout_sessionUpdateManyWithoutPayment_cardNestedInput
    app_user?: app_userUpdateOneRequiredWithoutPayment_cardNestedInput
  }

  export type payment_cardUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    security_code?: StringFieldUpdateOperationsInput | string
    expiration_month?: StringFieldUpdateOperationsInput | string
    expiration_year?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    payment_card_type?: StringFieldUpdateOperationsInput | string
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutPayment_cardNestedInput
  }

  export type addressUpsertWithoutOrder_order_shipping_address_idToaddressInput = {
    update: XOR<addressUpdateWithoutOrder_order_shipping_address_idToaddressInput, addressUncheckedUpdateWithoutOrder_order_shipping_address_idToaddressInput>
    create: XOR<addressCreateWithoutOrder_order_shipping_address_idToaddressInput, addressUncheckedCreateWithoutOrder_order_shipping_address_idToaddressInput>
    where?: addressWhereInput
  }

  export type addressUpdateToOneWithWhereWithoutOrder_order_shipping_address_idToaddressInput = {
    where?: addressWhereInput
    data: XOR<addressUpdateWithoutOrder_order_shipping_address_idToaddressInput, addressUncheckedUpdateWithoutOrder_order_shipping_address_idToaddressInput>
  }

  export type addressUpdateWithoutOrder_order_shipping_address_idToaddressInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    app_user?: app_userUpdateOneRequiredWithoutAddressNestedInput
    checkout_session?: checkout_sessionUpdateManyWithoutAddressNestedInput
    order_order_billing_address_idToaddress?: orderUpdateManyWithoutAddress_order_billing_address_idToaddressNestedInput
  }

  export type addressUncheckedUpdateWithoutOrder_order_shipping_address_idToaddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutAddressNestedInput
    order_order_billing_address_idToaddress?: orderUncheckedUpdateManyWithoutAddress_order_billing_address_idToaddressNestedInput
  }

  export type app_userUpsertWithoutOrderInput = {
    update: XOR<app_userUpdateWithoutOrderInput, app_userUncheckedUpdateWithoutOrderInput>
    create: XOR<app_userCreateWithoutOrderInput, app_userUncheckedCreateWithoutOrderInput>
    where?: app_userWhereInput
  }

  export type app_userUpdateToOneWithWhereWithoutOrderInput = {
    where?: app_userWhereInput
    data: XOR<app_userUpdateWithoutOrderInput, app_userUncheckedUpdateWithoutOrderInput>
  }

  export type app_userUpdateWithoutOrderInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: addressUpdateManyWithoutApp_userNestedInput
    cart?: cartUpdateManyWithoutApp_userNestedInput
    checkout_session?: checkout_sessionUpdateManyWithoutApp_userNestedInput
    payment_card?: payment_cardUpdateManyWithoutApp_userNestedInput
  }

  export type app_userUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: addressUncheckedUpdateManyWithoutApp_userNestedInput
    cart?: cartUncheckedUpdateManyWithoutApp_userNestedInput
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutApp_userNestedInput
    payment_card?: payment_cardUncheckedUpdateManyWithoutApp_userNestedInput
  }

  export type order_productUpsertWithWhereUniqueWithoutOrderInput = {
    where: order_productWhereUniqueInput
    update: XOR<order_productUpdateWithoutOrderInput, order_productUncheckedUpdateWithoutOrderInput>
    create: XOR<order_productCreateWithoutOrderInput, order_productUncheckedCreateWithoutOrderInput>
  }

  export type order_productUpdateWithWhereUniqueWithoutOrderInput = {
    where: order_productWhereUniqueInput
    data: XOR<order_productUpdateWithoutOrderInput, order_productUncheckedUpdateWithoutOrderInput>
  }

  export type order_productUpdateManyWithWhereWithoutOrderInput = {
    where: order_productScalarWhereInput
    data: XOR<order_productUpdateManyMutationInput, order_productUncheckedUpdateManyWithoutOrderInput>
  }

  export type order_productScalarWhereInput = {
    AND?: order_productScalarWhereInput | order_productScalarWhereInput[]
    OR?: order_productScalarWhereInput[]
    NOT?: order_productScalarWhereInput | order_productScalarWhereInput[]
    order_id?: IntFilter<"order_product"> | number
    product_id?: IntFilter<"order_product"> | number
    quantity?: IntFilter<"order_product"> | number
  }

  export type orderCreateWithoutOrder_productInput = {
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    address_order_billing_address_idToaddress: addressCreateNestedOneWithoutOrder_order_billing_address_idToaddressInput
    payment_card: payment_cardCreateNestedOneWithoutOrderInput
    address_order_shipping_address_idToaddress: addressCreateNestedOneWithoutOrder_order_shipping_address_idToaddressInput
    app_user: app_userCreateNestedOneWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutOrder_productInput = {
    id?: number
    user_id: number
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    payment_card_id: number
    shipping_address_id: number
    billing_address_id: number
  }

  export type orderCreateOrConnectWithoutOrder_productInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutOrder_productInput, orderUncheckedCreateWithoutOrder_productInput>
  }

  export type productCreateWithoutOrder_productInput = {
    name: string
    description: string
    inventory?: number
    price: Decimal | DecimalJsLike | number | string
    category_code: string
    discount_type?: string
    total_sold?: number
    img_filename: string
    discount_percent?: number
    item_code: string
    cart_product?: cart_productCreateNestedManyWithoutProductInput
  }

  export type productUncheckedCreateWithoutOrder_productInput = {
    id?: number
    name: string
    description: string
    inventory?: number
    price: Decimal | DecimalJsLike | number | string
    category_code: string
    discount_type?: string
    total_sold?: number
    img_filename: string
    discount_percent?: number
    item_code: string
    cart_product?: cart_productUncheckedCreateNestedManyWithoutProductInput
  }

  export type productCreateOrConnectWithoutOrder_productInput = {
    where: productWhereUniqueInput
    create: XOR<productCreateWithoutOrder_productInput, productUncheckedCreateWithoutOrder_productInput>
  }

  export type orderUpsertWithoutOrder_productInput = {
    update: XOR<orderUpdateWithoutOrder_productInput, orderUncheckedUpdateWithoutOrder_productInput>
    create: XOR<orderCreateWithoutOrder_productInput, orderUncheckedCreateWithoutOrder_productInput>
    where?: orderWhereInput
  }

  export type orderUpdateToOneWithWhereWithoutOrder_productInput = {
    where?: orderWhereInput
    data: XOR<orderUpdateWithoutOrder_productInput, orderUncheckedUpdateWithoutOrder_productInput>
  }

  export type orderUpdateWithoutOrder_productInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    address_order_billing_address_idToaddress?: addressUpdateOneRequiredWithoutOrder_order_billing_address_idToaddressNestedInput
    payment_card?: payment_cardUpdateOneRequiredWithoutOrderNestedInput
    address_order_shipping_address_idToaddress?: addressUpdateOneRequiredWithoutOrder_order_shipping_address_idToaddressNestedInput
    app_user?: app_userUpdateOneRequiredWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutOrder_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    payment_card_id?: IntFieldUpdateOperationsInput | number
    shipping_address_id?: IntFieldUpdateOperationsInput | number
    billing_address_id?: IntFieldUpdateOperationsInput | number
  }

  export type productUpsertWithoutOrder_productInput = {
    update: XOR<productUpdateWithoutOrder_productInput, productUncheckedUpdateWithoutOrder_productInput>
    create: XOR<productCreateWithoutOrder_productInput, productUncheckedCreateWithoutOrder_productInput>
    where?: productWhereInput
  }

  export type productUpdateToOneWithWhereWithoutOrder_productInput = {
    where?: productWhereInput
    data: XOR<productUpdateWithoutOrder_productInput, productUncheckedUpdateWithoutOrder_productInput>
  }

  export type productUpdateWithoutOrder_productInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category_code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    total_sold?: IntFieldUpdateOperationsInput | number
    img_filename?: StringFieldUpdateOperationsInput | string
    discount_percent?: IntFieldUpdateOperationsInput | number
    item_code?: StringFieldUpdateOperationsInput | string
    cart_product?: cart_productUpdateManyWithoutProductNestedInput
  }

  export type productUncheckedUpdateWithoutOrder_productInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    inventory?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category_code?: StringFieldUpdateOperationsInput | string
    discount_type?: StringFieldUpdateOperationsInput | string
    total_sold?: IntFieldUpdateOperationsInput | number
    img_filename?: StringFieldUpdateOperationsInput | string
    discount_percent?: IntFieldUpdateOperationsInput | number
    item_code?: StringFieldUpdateOperationsInput | string
    cart_product?: cart_productUncheckedUpdateManyWithoutProductNestedInput
  }

  export type cart_productCreateWithoutProductInput = {
    quantity?: number
    cart: cartCreateNestedOneWithoutCart_productInput
  }

  export type cart_productUncheckedCreateWithoutProductInput = {
    cart_id: number
    quantity?: number
  }

  export type cart_productCreateOrConnectWithoutProductInput = {
    where: cart_productWhereUniqueInput
    create: XOR<cart_productCreateWithoutProductInput, cart_productUncheckedCreateWithoutProductInput>
  }

  export type cart_productCreateManyProductInputEnvelope = {
    data: cart_productCreateManyProductInput | cart_productCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type order_productCreateWithoutProductInput = {
    quantity: number
    order: orderCreateNestedOneWithoutOrder_productInput
  }

  export type order_productUncheckedCreateWithoutProductInput = {
    order_id: number
    quantity: number
  }

  export type order_productCreateOrConnectWithoutProductInput = {
    where: order_productWhereUniqueInput
    create: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput>
  }

  export type order_productCreateManyProductInputEnvelope = {
    data: order_productCreateManyProductInput | order_productCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type cart_productUpsertWithWhereUniqueWithoutProductInput = {
    where: cart_productWhereUniqueInput
    update: XOR<cart_productUpdateWithoutProductInput, cart_productUncheckedUpdateWithoutProductInput>
    create: XOR<cart_productCreateWithoutProductInput, cart_productUncheckedCreateWithoutProductInput>
  }

  export type cart_productUpdateWithWhereUniqueWithoutProductInput = {
    where: cart_productWhereUniqueInput
    data: XOR<cart_productUpdateWithoutProductInput, cart_productUncheckedUpdateWithoutProductInput>
  }

  export type cart_productUpdateManyWithWhereWithoutProductInput = {
    where: cart_productScalarWhereInput
    data: XOR<cart_productUpdateManyMutationInput, cart_productUncheckedUpdateManyWithoutProductInput>
  }

  export type order_productUpsertWithWhereUniqueWithoutProductInput = {
    where: order_productWhereUniqueInput
    update: XOR<order_productUpdateWithoutProductInput, order_productUncheckedUpdateWithoutProductInput>
    create: XOR<order_productCreateWithoutProductInput, order_productUncheckedCreateWithoutProductInput>
  }

  export type order_productUpdateWithWhereUniqueWithoutProductInput = {
    where: order_productWhereUniqueInput
    data: XOR<order_productUpdateWithoutProductInput, order_productUncheckedUpdateWithoutProductInput>
  }

  export type order_productUpdateManyWithWhereWithoutProductInput = {
    where: order_productScalarWhereInput
    data: XOR<order_productUpdateManyMutationInput, order_productUncheckedUpdateManyWithoutProductInput>
  }

  export type app_userCreateWithoutAddressInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    cart?: cartCreateNestedManyWithoutApp_userInput
    checkout_session?: checkout_sessionCreateNestedManyWithoutApp_userInput
    order?: orderCreateNestedManyWithoutApp_userInput
    payment_card?: payment_cardCreateNestedManyWithoutApp_userInput
  }

  export type app_userUncheckedCreateWithoutAddressInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    cart?: cartUncheckedCreateNestedManyWithoutApp_userInput
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutApp_userInput
    order?: orderUncheckedCreateNestedManyWithoutApp_userInput
    payment_card?: payment_cardUncheckedCreateNestedManyWithoutApp_userInput
  }

  export type app_userCreateOrConnectWithoutAddressInput = {
    where: app_userWhereUniqueInput
    create: XOR<app_userCreateWithoutAddressInput, app_userUncheckedCreateWithoutAddressInput>
  }

  export type checkout_sessionCreateWithoutAddressInput = {
    stage?: string
    billing_address_id?: number | null
    cart: cartCreateNestedOneWithoutCheckout_sessionInput
    payment_card?: payment_cardCreateNestedOneWithoutCheckout_sessionInput
    app_user: app_userCreateNestedOneWithoutCheckout_sessionInput
  }

  export type checkout_sessionUncheckedCreateWithoutAddressInput = {
    id?: number
    user_id: number
    payment_card_id?: number | null
    cart_id: number
    stage?: string
    billing_address_id?: number | null
  }

  export type checkout_sessionCreateOrConnectWithoutAddressInput = {
    where: checkout_sessionWhereUniqueInput
    create: XOR<checkout_sessionCreateWithoutAddressInput, checkout_sessionUncheckedCreateWithoutAddressInput>
  }

  export type checkout_sessionCreateManyAddressInputEnvelope = {
    data: checkout_sessionCreateManyAddressInput | checkout_sessionCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type orderCreateWithoutAddress_order_billing_address_idToaddressInput = {
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    payment_card: payment_cardCreateNestedOneWithoutOrderInput
    address_order_shipping_address_idToaddress: addressCreateNestedOneWithoutOrder_order_shipping_address_idToaddressInput
    app_user: app_userCreateNestedOneWithoutOrderInput
    order_product?: order_productCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutAddress_order_billing_address_idToaddressInput = {
    id?: number
    user_id: number
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    payment_card_id: number
    shipping_address_id: number
    order_product?: order_productUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutAddress_order_billing_address_idToaddressInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutAddress_order_billing_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_billing_address_idToaddressInput>
  }

  export type orderCreateManyAddress_order_billing_address_idToaddressInputEnvelope = {
    data: orderCreateManyAddress_order_billing_address_idToaddressInput | orderCreateManyAddress_order_billing_address_idToaddressInput[]
    skipDuplicates?: boolean
  }

  export type orderCreateWithoutAddress_order_shipping_address_idToaddressInput = {
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    address_order_billing_address_idToaddress: addressCreateNestedOneWithoutOrder_order_billing_address_idToaddressInput
    payment_card: payment_cardCreateNestedOneWithoutOrderInput
    app_user: app_userCreateNestedOneWithoutOrderInput
    order_product?: order_productCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutAddress_order_shipping_address_idToaddressInput = {
    id?: number
    user_id: number
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    payment_card_id: number
    billing_address_id: number
    order_product?: order_productUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutAddress_order_shipping_address_idToaddressInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutAddress_order_shipping_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_shipping_address_idToaddressInput>
  }

  export type orderCreateManyAddress_order_shipping_address_idToaddressInputEnvelope = {
    data: orderCreateManyAddress_order_shipping_address_idToaddressInput | orderCreateManyAddress_order_shipping_address_idToaddressInput[]
    skipDuplicates?: boolean
  }

  export type app_userUpsertWithoutAddressInput = {
    update: XOR<app_userUpdateWithoutAddressInput, app_userUncheckedUpdateWithoutAddressInput>
    create: XOR<app_userCreateWithoutAddressInput, app_userUncheckedCreateWithoutAddressInput>
    where?: app_userWhereInput
  }

  export type app_userUpdateToOneWithWhereWithoutAddressInput = {
    where?: app_userWhereInput
    data: XOR<app_userUpdateWithoutAddressInput, app_userUncheckedUpdateWithoutAddressInput>
  }

  export type app_userUpdateWithoutAddressInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cart?: cartUpdateManyWithoutApp_userNestedInput
    checkout_session?: checkout_sessionUpdateManyWithoutApp_userNestedInput
    order?: orderUpdateManyWithoutApp_userNestedInput
    payment_card?: payment_cardUpdateManyWithoutApp_userNestedInput
  }

  export type app_userUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cart?: cartUncheckedUpdateManyWithoutApp_userNestedInput
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutApp_userNestedInput
    order?: orderUncheckedUpdateManyWithoutApp_userNestedInput
    payment_card?: payment_cardUncheckedUpdateManyWithoutApp_userNestedInput
  }

  export type checkout_sessionUpsertWithWhereUniqueWithoutAddressInput = {
    where: checkout_sessionWhereUniqueInput
    update: XOR<checkout_sessionUpdateWithoutAddressInput, checkout_sessionUncheckedUpdateWithoutAddressInput>
    create: XOR<checkout_sessionCreateWithoutAddressInput, checkout_sessionUncheckedCreateWithoutAddressInput>
  }

  export type checkout_sessionUpdateWithWhereUniqueWithoutAddressInput = {
    where: checkout_sessionWhereUniqueInput
    data: XOR<checkout_sessionUpdateWithoutAddressInput, checkout_sessionUncheckedUpdateWithoutAddressInput>
  }

  export type checkout_sessionUpdateManyWithWhereWithoutAddressInput = {
    where: checkout_sessionScalarWhereInput
    data: XOR<checkout_sessionUpdateManyMutationInput, checkout_sessionUncheckedUpdateManyWithoutAddressInput>
  }

  export type orderUpsertWithWhereUniqueWithoutAddress_order_billing_address_idToaddressInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutAddress_order_billing_address_idToaddressInput, orderUncheckedUpdateWithoutAddress_order_billing_address_idToaddressInput>
    create: XOR<orderCreateWithoutAddress_order_billing_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_billing_address_idToaddressInput>
  }

  export type orderUpdateWithWhereUniqueWithoutAddress_order_billing_address_idToaddressInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutAddress_order_billing_address_idToaddressInput, orderUncheckedUpdateWithoutAddress_order_billing_address_idToaddressInput>
  }

  export type orderUpdateManyWithWhereWithoutAddress_order_billing_address_idToaddressInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutAddress_order_billing_address_idToaddressInput>
  }

  export type orderUpsertWithWhereUniqueWithoutAddress_order_shipping_address_idToaddressInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutAddress_order_shipping_address_idToaddressInput, orderUncheckedUpdateWithoutAddress_order_shipping_address_idToaddressInput>
    create: XOR<orderCreateWithoutAddress_order_shipping_address_idToaddressInput, orderUncheckedCreateWithoutAddress_order_shipping_address_idToaddressInput>
  }

  export type orderUpdateWithWhereUniqueWithoutAddress_order_shipping_address_idToaddressInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutAddress_order_shipping_address_idToaddressInput, orderUncheckedUpdateWithoutAddress_order_shipping_address_idToaddressInput>
  }

  export type orderUpdateManyWithWhereWithoutAddress_order_shipping_address_idToaddressInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutAddress_order_shipping_address_idToaddressInput>
  }

  export type cartCreateWithoutCheckout_sessionInput = {
    num_items?: number
    total?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    app_user: app_userCreateNestedOneWithoutCartInput
    cart_product?: cart_productCreateNestedManyWithoutCartInput
  }

  export type cartUncheckedCreateWithoutCheckout_sessionInput = {
    id?: number
    user_id: number
    num_items?: number
    total?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
    cart_product?: cart_productUncheckedCreateNestedManyWithoutCartInput
  }

  export type cartCreateOrConnectWithoutCheckout_sessionInput = {
    where: cartWhereUniqueInput
    create: XOR<cartCreateWithoutCheckout_sessionInput, cartUncheckedCreateWithoutCheckout_sessionInput>
  }

  export type payment_cardCreateWithoutCheckout_sessionInput = {
    card_number: string
    security_code: string
    expiration_month: string
    expiration_year: string
    first_name: string
    last_name: string
    payment_card_type: string
    order?: orderCreateNestedManyWithoutPayment_cardInput
    app_user: app_userCreateNestedOneWithoutPayment_cardInput
  }

  export type payment_cardUncheckedCreateWithoutCheckout_sessionInput = {
    id?: number
    user_id: number
    card_number: string
    security_code: string
    expiration_month: string
    expiration_year: string
    first_name: string
    last_name: string
    payment_card_type: string
    order?: orderUncheckedCreateNestedManyWithoutPayment_cardInput
  }

  export type payment_cardCreateOrConnectWithoutCheckout_sessionInput = {
    where: payment_cardWhereUniqueInput
    create: XOR<payment_cardCreateWithoutCheckout_sessionInput, payment_cardUncheckedCreateWithoutCheckout_sessionInput>
  }

  export type addressCreateWithoutCheckout_sessionInput = {
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    unit?: string | null
    app_user: app_userCreateNestedOneWithoutAddressInput
    order_order_billing_address_idToaddress?: orderCreateNestedManyWithoutAddress_order_billing_address_idToaddressInput
    order_order_shipping_address_idToaddress?: orderCreateNestedManyWithoutAddress_order_shipping_address_idToaddressInput
  }

  export type addressUncheckedCreateWithoutCheckout_sessionInput = {
    id?: number
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    user_id: number
    unit?: string | null
    order_order_billing_address_idToaddress?: orderUncheckedCreateNestedManyWithoutAddress_order_billing_address_idToaddressInput
    order_order_shipping_address_idToaddress?: orderUncheckedCreateNestedManyWithoutAddress_order_shipping_address_idToaddressInput
  }

  export type addressCreateOrConnectWithoutCheckout_sessionInput = {
    where: addressWhereUniqueInput
    create: XOR<addressCreateWithoutCheckout_sessionInput, addressUncheckedCreateWithoutCheckout_sessionInput>
  }

  export type app_userCreateWithoutCheckout_sessionInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    address?: addressCreateNestedManyWithoutApp_userInput
    cart?: cartCreateNestedManyWithoutApp_userInput
    order?: orderCreateNestedManyWithoutApp_userInput
    payment_card?: payment_cardCreateNestedManyWithoutApp_userInput
  }

  export type app_userUncheckedCreateWithoutCheckout_sessionInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    address?: addressUncheckedCreateNestedManyWithoutApp_userInput
    cart?: cartUncheckedCreateNestedManyWithoutApp_userInput
    order?: orderUncheckedCreateNestedManyWithoutApp_userInput
    payment_card?: payment_cardUncheckedCreateNestedManyWithoutApp_userInput
  }

  export type app_userCreateOrConnectWithoutCheckout_sessionInput = {
    where: app_userWhereUniqueInput
    create: XOR<app_userCreateWithoutCheckout_sessionInput, app_userUncheckedCreateWithoutCheckout_sessionInput>
  }

  export type cartUpsertWithoutCheckout_sessionInput = {
    update: XOR<cartUpdateWithoutCheckout_sessionInput, cartUncheckedUpdateWithoutCheckout_sessionInput>
    create: XOR<cartCreateWithoutCheckout_sessionInput, cartUncheckedCreateWithoutCheckout_sessionInput>
    where?: cartWhereInput
  }

  export type cartUpdateToOneWithWhereWithoutCheckout_sessionInput = {
    where?: cartWhereInput
    data: XOR<cartUpdateWithoutCheckout_sessionInput, cartUncheckedUpdateWithoutCheckout_sessionInput>
  }

  export type cartUpdateWithoutCheckout_sessionInput = {
    num_items?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    app_user?: app_userUpdateOneRequiredWithoutCartNestedInput
    cart_product?: cart_productUpdateManyWithoutCartNestedInput
  }

  export type cartUncheckedUpdateWithoutCheckout_sessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    num_items?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cart_product?: cart_productUncheckedUpdateManyWithoutCartNestedInput
  }

  export type payment_cardUpsertWithoutCheckout_sessionInput = {
    update: XOR<payment_cardUpdateWithoutCheckout_sessionInput, payment_cardUncheckedUpdateWithoutCheckout_sessionInput>
    create: XOR<payment_cardCreateWithoutCheckout_sessionInput, payment_cardUncheckedCreateWithoutCheckout_sessionInput>
    where?: payment_cardWhereInput
  }

  export type payment_cardUpdateToOneWithWhereWithoutCheckout_sessionInput = {
    where?: payment_cardWhereInput
    data: XOR<payment_cardUpdateWithoutCheckout_sessionInput, payment_cardUncheckedUpdateWithoutCheckout_sessionInput>
  }

  export type payment_cardUpdateWithoutCheckout_sessionInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    security_code?: StringFieldUpdateOperationsInput | string
    expiration_month?: StringFieldUpdateOperationsInput | string
    expiration_year?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    payment_card_type?: StringFieldUpdateOperationsInput | string
    order?: orderUpdateManyWithoutPayment_cardNestedInput
    app_user?: app_userUpdateOneRequiredWithoutPayment_cardNestedInput
  }

  export type payment_cardUncheckedUpdateWithoutCheckout_sessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    security_code?: StringFieldUpdateOperationsInput | string
    expiration_month?: StringFieldUpdateOperationsInput | string
    expiration_year?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    payment_card_type?: StringFieldUpdateOperationsInput | string
    order?: orderUncheckedUpdateManyWithoutPayment_cardNestedInput
  }

  export type addressUpsertWithoutCheckout_sessionInput = {
    update: XOR<addressUpdateWithoutCheckout_sessionInput, addressUncheckedUpdateWithoutCheckout_sessionInput>
    create: XOR<addressCreateWithoutCheckout_sessionInput, addressUncheckedCreateWithoutCheckout_sessionInput>
    where?: addressWhereInput
  }

  export type addressUpdateToOneWithWhereWithoutCheckout_sessionInput = {
    where?: addressWhereInput
    data: XOR<addressUpdateWithoutCheckout_sessionInput, addressUncheckedUpdateWithoutCheckout_sessionInput>
  }

  export type addressUpdateWithoutCheckout_sessionInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    app_user?: app_userUpdateOneRequiredWithoutAddressNestedInput
    order_order_billing_address_idToaddress?: orderUpdateManyWithoutAddress_order_billing_address_idToaddressNestedInput
    order_order_shipping_address_idToaddress?: orderUpdateManyWithoutAddress_order_shipping_address_idToaddressNestedInput
  }

  export type addressUncheckedUpdateWithoutCheckout_sessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    order_order_billing_address_idToaddress?: orderUncheckedUpdateManyWithoutAddress_order_billing_address_idToaddressNestedInput
    order_order_shipping_address_idToaddress?: orderUncheckedUpdateManyWithoutAddress_order_shipping_address_idToaddressNestedInput
  }

  export type app_userUpsertWithoutCheckout_sessionInput = {
    update: XOR<app_userUpdateWithoutCheckout_sessionInput, app_userUncheckedUpdateWithoutCheckout_sessionInput>
    create: XOR<app_userCreateWithoutCheckout_sessionInput, app_userUncheckedCreateWithoutCheckout_sessionInput>
    where?: app_userWhereInput
  }

  export type app_userUpdateToOneWithWhereWithoutCheckout_sessionInput = {
    where?: app_userWhereInput
    data: XOR<app_userUpdateWithoutCheckout_sessionInput, app_userUncheckedUpdateWithoutCheckout_sessionInput>
  }

  export type app_userUpdateWithoutCheckout_sessionInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: addressUpdateManyWithoutApp_userNestedInput
    cart?: cartUpdateManyWithoutApp_userNestedInput
    order?: orderUpdateManyWithoutApp_userNestedInput
    payment_card?: payment_cardUpdateManyWithoutApp_userNestedInput
  }

  export type app_userUncheckedUpdateWithoutCheckout_sessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: addressUncheckedUpdateManyWithoutApp_userNestedInput
    cart?: cartUncheckedUpdateManyWithoutApp_userNestedInput
    order?: orderUncheckedUpdateManyWithoutApp_userNestedInput
    payment_card?: payment_cardUncheckedUpdateManyWithoutApp_userNestedInput
  }

  export type checkout_sessionCreateWithoutPayment_cardInput = {
    stage?: string
    billing_address_id?: number | null
    cart: cartCreateNestedOneWithoutCheckout_sessionInput
    address?: addressCreateNestedOneWithoutCheckout_sessionInput
    app_user: app_userCreateNestedOneWithoutCheckout_sessionInput
  }

  export type checkout_sessionUncheckedCreateWithoutPayment_cardInput = {
    id?: number
    user_id: number
    shipping_address_id?: number | null
    cart_id: number
    stage?: string
    billing_address_id?: number | null
  }

  export type checkout_sessionCreateOrConnectWithoutPayment_cardInput = {
    where: checkout_sessionWhereUniqueInput
    create: XOR<checkout_sessionCreateWithoutPayment_cardInput, checkout_sessionUncheckedCreateWithoutPayment_cardInput>
  }

  export type checkout_sessionCreateManyPayment_cardInputEnvelope = {
    data: checkout_sessionCreateManyPayment_cardInput | checkout_sessionCreateManyPayment_cardInput[]
    skipDuplicates?: boolean
  }

  export type orderCreateWithoutPayment_cardInput = {
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    address_order_billing_address_idToaddress: addressCreateNestedOneWithoutOrder_order_billing_address_idToaddressInput
    address_order_shipping_address_idToaddress: addressCreateNestedOneWithoutOrder_order_shipping_address_idToaddressInput
    app_user: app_userCreateNestedOneWithoutOrderInput
    order_product?: order_productCreateNestedManyWithoutOrderInput
  }

  export type orderUncheckedCreateWithoutPayment_cardInput = {
    id?: number
    user_id: number
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    shipping_address_id: number
    billing_address_id: number
    order_product?: order_productUncheckedCreateNestedManyWithoutOrderInput
  }

  export type orderCreateOrConnectWithoutPayment_cardInput = {
    where: orderWhereUniqueInput
    create: XOR<orderCreateWithoutPayment_cardInput, orderUncheckedCreateWithoutPayment_cardInput>
  }

  export type orderCreateManyPayment_cardInputEnvelope = {
    data: orderCreateManyPayment_cardInput | orderCreateManyPayment_cardInput[]
    skipDuplicates?: boolean
  }

  export type app_userCreateWithoutPayment_cardInput = {
    first_name: string
    last_name: string
    email: string
    password: string
    address?: addressCreateNestedManyWithoutApp_userInput
    cart?: cartCreateNestedManyWithoutApp_userInput
    checkout_session?: checkout_sessionCreateNestedManyWithoutApp_userInput
    order?: orderCreateNestedManyWithoutApp_userInput
  }

  export type app_userUncheckedCreateWithoutPayment_cardInput = {
    id?: number
    first_name: string
    last_name: string
    email: string
    password: string
    address?: addressUncheckedCreateNestedManyWithoutApp_userInput
    cart?: cartUncheckedCreateNestedManyWithoutApp_userInput
    checkout_session?: checkout_sessionUncheckedCreateNestedManyWithoutApp_userInput
    order?: orderUncheckedCreateNestedManyWithoutApp_userInput
  }

  export type app_userCreateOrConnectWithoutPayment_cardInput = {
    where: app_userWhereUniqueInput
    create: XOR<app_userCreateWithoutPayment_cardInput, app_userUncheckedCreateWithoutPayment_cardInput>
  }

  export type checkout_sessionUpsertWithWhereUniqueWithoutPayment_cardInput = {
    where: checkout_sessionWhereUniqueInput
    update: XOR<checkout_sessionUpdateWithoutPayment_cardInput, checkout_sessionUncheckedUpdateWithoutPayment_cardInput>
    create: XOR<checkout_sessionCreateWithoutPayment_cardInput, checkout_sessionUncheckedCreateWithoutPayment_cardInput>
  }

  export type checkout_sessionUpdateWithWhereUniqueWithoutPayment_cardInput = {
    where: checkout_sessionWhereUniqueInput
    data: XOR<checkout_sessionUpdateWithoutPayment_cardInput, checkout_sessionUncheckedUpdateWithoutPayment_cardInput>
  }

  export type checkout_sessionUpdateManyWithWhereWithoutPayment_cardInput = {
    where: checkout_sessionScalarWhereInput
    data: XOR<checkout_sessionUpdateManyMutationInput, checkout_sessionUncheckedUpdateManyWithoutPayment_cardInput>
  }

  export type orderUpsertWithWhereUniqueWithoutPayment_cardInput = {
    where: orderWhereUniqueInput
    update: XOR<orderUpdateWithoutPayment_cardInput, orderUncheckedUpdateWithoutPayment_cardInput>
    create: XOR<orderCreateWithoutPayment_cardInput, orderUncheckedCreateWithoutPayment_cardInput>
  }

  export type orderUpdateWithWhereUniqueWithoutPayment_cardInput = {
    where: orderWhereUniqueInput
    data: XOR<orderUpdateWithoutPayment_cardInput, orderUncheckedUpdateWithoutPayment_cardInput>
  }

  export type orderUpdateManyWithWhereWithoutPayment_cardInput = {
    where: orderScalarWhereInput
    data: XOR<orderUpdateManyMutationInput, orderUncheckedUpdateManyWithoutPayment_cardInput>
  }

  export type app_userUpsertWithoutPayment_cardInput = {
    update: XOR<app_userUpdateWithoutPayment_cardInput, app_userUncheckedUpdateWithoutPayment_cardInput>
    create: XOR<app_userCreateWithoutPayment_cardInput, app_userUncheckedCreateWithoutPayment_cardInput>
    where?: app_userWhereInput
  }

  export type app_userUpdateToOneWithWhereWithoutPayment_cardInput = {
    where?: app_userWhereInput
    data: XOR<app_userUpdateWithoutPayment_cardInput, app_userUncheckedUpdateWithoutPayment_cardInput>
  }

  export type app_userUpdateWithoutPayment_cardInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: addressUpdateManyWithoutApp_userNestedInput
    cart?: cartUpdateManyWithoutApp_userNestedInput
    checkout_session?: checkout_sessionUpdateManyWithoutApp_userNestedInput
    order?: orderUpdateManyWithoutApp_userNestedInput
  }

  export type app_userUncheckedUpdateWithoutPayment_cardInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: addressUncheckedUpdateManyWithoutApp_userNestedInput
    cart?: cartUncheckedUpdateManyWithoutApp_userNestedInput
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutApp_userNestedInput
    order?: orderUncheckedUpdateManyWithoutApp_userNestedInput
  }

  export type addressCreateManyApp_userInput = {
    id?: number
    first_name: string
    last_name: string
    address: string
    city: string
    province: string
    country: string
    postal_code: string
    phone_number: string
    address_type: string
    unit?: string | null
  }

  export type cartCreateManyApp_userInput = {
    id?: number
    num_items?: number
    total?: Decimal | DecimalJsLike | number | string
    subtotal?: Decimal | DecimalJsLike | number | string
    taxes?: Decimal | DecimalJsLike | number | string
  }

  export type checkout_sessionCreateManyApp_userInput = {
    id?: number
    payment_card_id?: number | null
    shipping_address_id?: number | null
    cart_id: number
    stage?: string
    billing_address_id?: number | null
  }

  export type orderCreateManyApp_userInput = {
    id?: number
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    payment_card_id: number
    shipping_address_id: number
    billing_address_id: number
  }

  export type payment_cardCreateManyApp_userInput = {
    id?: number
    card_number: string
    security_code: string
    expiration_month: string
    expiration_year: string
    first_name: string
    last_name: string
    payment_card_type: string
  }

  export type addressUpdateWithoutApp_userInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_session?: checkout_sessionUpdateManyWithoutAddressNestedInput
    order_order_billing_address_idToaddress?: orderUpdateManyWithoutAddress_order_billing_address_idToaddressNestedInput
    order_order_shipping_address_idToaddress?: orderUpdateManyWithoutAddress_order_shipping_address_idToaddressNestedInput
  }

  export type addressUncheckedUpdateWithoutApp_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutAddressNestedInput
    order_order_billing_address_idToaddress?: orderUncheckedUpdateManyWithoutAddress_order_billing_address_idToaddressNestedInput
    order_order_shipping_address_idToaddress?: orderUncheckedUpdateManyWithoutAddress_order_shipping_address_idToaddressNestedInput
  }

  export type addressUncheckedUpdateManyWithoutApp_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    province?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    postal_code?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    address_type?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cartUpdateWithoutApp_userInput = {
    num_items?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cart_product?: cart_productUpdateManyWithoutCartNestedInput
    checkout_session?: checkout_sessionUpdateManyWithoutCartNestedInput
  }

  export type cartUncheckedUpdateWithoutApp_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    num_items?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cart_product?: cart_productUncheckedUpdateManyWithoutCartNestedInput
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutCartNestedInput
  }

  export type cartUncheckedUpdateManyWithoutApp_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    num_items?: IntFieldUpdateOperationsInput | number
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type checkout_sessionUpdateWithoutApp_userInput = {
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUpdateOneRequiredWithoutCheckout_sessionNestedInput
    payment_card?: payment_cardUpdateOneWithoutCheckout_sessionNestedInput
    address?: addressUpdateOneWithoutCheckout_sessionNestedInput
  }

  export type checkout_sessionUncheckedUpdateWithoutApp_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart_id?: IntFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type checkout_sessionUncheckedUpdateManyWithoutApp_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart_id?: IntFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type orderUpdateWithoutApp_userInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    address_order_billing_address_idToaddress?: addressUpdateOneRequiredWithoutOrder_order_billing_address_idToaddressNestedInput
    payment_card?: payment_cardUpdateOneRequiredWithoutOrderNestedInput
    address_order_shipping_address_idToaddress?: addressUpdateOneRequiredWithoutOrder_order_shipping_address_idToaddressNestedInput
    order_product?: order_productUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutApp_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    payment_card_id?: IntFieldUpdateOperationsInput | number
    shipping_address_id?: IntFieldUpdateOperationsInput | number
    billing_address_id?: IntFieldUpdateOperationsInput | number
    order_product?: order_productUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutApp_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    payment_card_id?: IntFieldUpdateOperationsInput | number
    shipping_address_id?: IntFieldUpdateOperationsInput | number
    billing_address_id?: IntFieldUpdateOperationsInput | number
  }

  export type payment_cardUpdateWithoutApp_userInput = {
    card_number?: StringFieldUpdateOperationsInput | string
    security_code?: StringFieldUpdateOperationsInput | string
    expiration_month?: StringFieldUpdateOperationsInput | string
    expiration_year?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    payment_card_type?: StringFieldUpdateOperationsInput | string
    checkout_session?: checkout_sessionUpdateManyWithoutPayment_cardNestedInput
    order?: orderUpdateManyWithoutPayment_cardNestedInput
  }

  export type payment_cardUncheckedUpdateWithoutApp_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    security_code?: StringFieldUpdateOperationsInput | string
    expiration_month?: StringFieldUpdateOperationsInput | string
    expiration_year?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    payment_card_type?: StringFieldUpdateOperationsInput | string
    checkout_session?: checkout_sessionUncheckedUpdateManyWithoutPayment_cardNestedInput
    order?: orderUncheckedUpdateManyWithoutPayment_cardNestedInput
  }

  export type payment_cardUncheckedUpdateManyWithoutApp_userInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_number?: StringFieldUpdateOperationsInput | string
    security_code?: StringFieldUpdateOperationsInput | string
    expiration_month?: StringFieldUpdateOperationsInput | string
    expiration_year?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    payment_card_type?: StringFieldUpdateOperationsInput | string
  }

  export type cart_productCreateManyCartInput = {
    product_id: number
    quantity?: number
  }

  export type checkout_sessionCreateManyCartInput = {
    id?: number
    user_id: number
    payment_card_id?: number | null
    shipping_address_id?: number | null
    stage?: string
    billing_address_id?: number | null
  }

  export type cart_productUpdateWithoutCartInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    product?: productUpdateOneRequiredWithoutCart_productNestedInput
  }

  export type cart_productUncheckedUpdateWithoutCartInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type cart_productUncheckedUpdateManyWithoutCartInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type checkout_sessionUpdateWithoutCartInput = {
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    payment_card?: payment_cardUpdateOneWithoutCheckout_sessionNestedInput
    address?: addressUpdateOneWithoutCheckout_sessionNestedInput
    app_user?: app_userUpdateOneRequiredWithoutCheckout_sessionNestedInput
  }

  export type checkout_sessionUncheckedUpdateWithoutCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    payment_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type checkout_sessionUncheckedUpdateManyWithoutCartInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    payment_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    shipping_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type order_productCreateManyOrderInput = {
    product_id: number
    quantity: number
  }

  export type order_productUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    product?: productUpdateOneRequiredWithoutOrder_productNestedInput
  }

  export type order_productUncheckedUpdateWithoutOrderInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type order_productUncheckedUpdateManyWithoutOrderInput = {
    product_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type cart_productCreateManyProductInput = {
    cart_id: number
    quantity?: number
  }

  export type order_productCreateManyProductInput = {
    order_id: number
    quantity: number
  }

  export type cart_productUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    cart?: cartUpdateOneRequiredWithoutCart_productNestedInput
  }

  export type cart_productUncheckedUpdateWithoutProductInput = {
    cart_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type cart_productUncheckedUpdateManyWithoutProductInput = {
    cart_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type order_productUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    order?: orderUpdateOneRequiredWithoutOrder_productNestedInput
  }

  export type order_productUncheckedUpdateWithoutProductInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type order_productUncheckedUpdateManyWithoutProductInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type checkout_sessionCreateManyAddressInput = {
    id?: number
    user_id: number
    payment_card_id?: number | null
    cart_id: number
    stage?: string
    billing_address_id?: number | null
  }

  export type orderCreateManyAddress_order_billing_address_idToaddressInput = {
    id?: number
    user_id: number
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    payment_card_id: number
    shipping_address_id: number
  }

  export type orderCreateManyAddress_order_shipping_address_idToaddressInput = {
    id?: number
    user_id: number
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    payment_card_id: number
    billing_address_id: number
  }

  export type checkout_sessionUpdateWithoutAddressInput = {
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUpdateOneRequiredWithoutCheckout_sessionNestedInput
    payment_card?: payment_cardUpdateOneWithoutCheckout_sessionNestedInput
    app_user?: app_userUpdateOneRequiredWithoutCheckout_sessionNestedInput
  }

  export type checkout_sessionUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    payment_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart_id?: IntFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type checkout_sessionUncheckedUpdateManyWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    payment_card_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart_id?: IntFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type orderUpdateWithoutAddress_order_billing_address_idToaddressInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    payment_card?: payment_cardUpdateOneRequiredWithoutOrderNestedInput
    address_order_shipping_address_idToaddress?: addressUpdateOneRequiredWithoutOrder_order_shipping_address_idToaddressNestedInput
    app_user?: app_userUpdateOneRequiredWithoutOrderNestedInput
    order_product?: order_productUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutAddress_order_billing_address_idToaddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    payment_card_id?: IntFieldUpdateOperationsInput | number
    shipping_address_id?: IntFieldUpdateOperationsInput | number
    order_product?: order_productUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutAddress_order_billing_address_idToaddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    payment_card_id?: IntFieldUpdateOperationsInput | number
    shipping_address_id?: IntFieldUpdateOperationsInput | number
  }

  export type orderUpdateWithoutAddress_order_shipping_address_idToaddressInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    address_order_billing_address_idToaddress?: addressUpdateOneRequiredWithoutOrder_order_billing_address_idToaddressNestedInput
    payment_card?: payment_cardUpdateOneRequiredWithoutOrderNestedInput
    app_user?: app_userUpdateOneRequiredWithoutOrderNestedInput
    order_product?: order_productUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutAddress_order_shipping_address_idToaddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    payment_card_id?: IntFieldUpdateOperationsInput | number
    billing_address_id?: IntFieldUpdateOperationsInput | number
    order_product?: order_productUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutAddress_order_shipping_address_idToaddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    payment_card_id?: IntFieldUpdateOperationsInput | number
    billing_address_id?: IntFieldUpdateOperationsInput | number
  }

  export type checkout_sessionCreateManyPayment_cardInput = {
    id?: number
    user_id: number
    shipping_address_id?: number | null
    cart_id: number
    stage?: string
    billing_address_id?: number | null
  }

  export type orderCreateManyPayment_cardInput = {
    id?: number
    user_id: number
    order_date?: Date | string
    total: Decimal | DecimalJsLike | number | string
    subtotal: Decimal | DecimalJsLike | number | string
    taxes: Decimal | DecimalJsLike | number | string
    num_items: number
    shipping_address_id: number
    billing_address_id: number
  }

  export type checkout_sessionUpdateWithoutPayment_cardInput = {
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart?: cartUpdateOneRequiredWithoutCheckout_sessionNestedInput
    address?: addressUpdateOneWithoutCheckout_sessionNestedInput
    app_user?: app_userUpdateOneRequiredWithoutCheckout_sessionNestedInput
  }

  export type checkout_sessionUncheckedUpdateWithoutPayment_cardInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    shipping_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart_id?: IntFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type checkout_sessionUncheckedUpdateManyWithoutPayment_cardInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    shipping_address_id?: NullableIntFieldUpdateOperationsInput | number | null
    cart_id?: IntFieldUpdateOperationsInput | number
    stage?: StringFieldUpdateOperationsInput | string
    billing_address_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type orderUpdateWithoutPayment_cardInput = {
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    address_order_billing_address_idToaddress?: addressUpdateOneRequiredWithoutOrder_order_billing_address_idToaddressNestedInput
    address_order_shipping_address_idToaddress?: addressUpdateOneRequiredWithoutOrder_order_shipping_address_idToaddressNestedInput
    app_user?: app_userUpdateOneRequiredWithoutOrderNestedInput
    order_product?: order_productUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateWithoutPayment_cardInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    shipping_address_id?: IntFieldUpdateOperationsInput | number
    billing_address_id?: IntFieldUpdateOperationsInput | number
    order_product?: order_productUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type orderUncheckedUpdateManyWithoutPayment_cardInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    order_date?: DateTimeFieldUpdateOperationsInput | Date | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    subtotal?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxes?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    num_items?: IntFieldUpdateOperationsInput | number
    shipping_address_id?: IntFieldUpdateOperationsInput | number
    billing_address_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use App_userCountOutputTypeDefaultArgs instead
     */
    export type App_userCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = App_userCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CartCountOutputTypeDefaultArgs instead
     */
    export type CartCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CartCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressCountOutputTypeDefaultArgs instead
     */
    export type AddressCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Payment_cardCountOutputTypeDefaultArgs instead
     */
    export type Payment_cardCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Payment_cardCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use app_userDefaultArgs instead
     */
    export type app_userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = app_userDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cartDefaultArgs instead
     */
    export type cartArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cartDefaultArgs<ExtArgs>
    /**
     * @deprecated Use cart_productDefaultArgs instead
     */
    export type cart_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = cart_productDefaultArgs<ExtArgs>
    /**
     * @deprecated Use orderDefaultArgs instead
     */
    export type orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = orderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use order_productDefaultArgs instead
     */
    export type order_productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = order_productDefaultArgs<ExtArgs>
    /**
     * @deprecated Use productDefaultArgs instead
     */
    export type productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = productDefaultArgs<ExtArgs>
    /**
     * @deprecated Use sessionDefaultArgs instead
     */
    export type sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = sessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use addressDefaultArgs instead
     */
    export type addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = addressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use checkout_sessionDefaultArgs instead
     */
    export type checkout_sessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = checkout_sessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use payment_cardDefaultArgs instead
     */
    export type payment_cardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = payment_cardDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}